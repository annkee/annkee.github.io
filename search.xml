<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用软件安装]]></title>
    <url>%2F2019%2F07%2F08%2Fsoftware%2F</url>
    <content type="text"><![CDATA[1 Acrobat Reader DC(强大的pdf阅读器)下载地址：https://acrobat.adobe.com/us/en/acrobat/pdf-reader.html?promoid=C4SZ2XDR&amp;mv=other 2 sublime text(文本编辑器)下载地址：http://www.sublimetext.com/3支持windows和Linux版本。常用快捷键： CTRL+h: 替换字符，在每行末尾添加字符，选择正则匹配*号，输入$，代表末尾，输入^代表行首，输入\s+$ 删除空白空格和空行 3 shutters百叶窗(资源管理器，并行多个资源管理器)下载地址：http://shutters.160.com 下载地址：https://q-dir.en.softonic.com 4 gif-LICEcap(gif录制工具)下载地址：https://www.cockos.com/licecap 5 十个免费的图片获取网站下载地址：http://www.sohu.com/a/239357937_714589 6 teamviewer 远程控制协作工具下载地址：https://www.teamviewer.cn/cn 7 postman api调用测试工具下载地址：https://www.getpostman.com/downloads 8 jmeter 测试工具 下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/source 9 foxmail 邮件工具下载地址：https://www.foxmail.com 10 PowerDesigner 建模工具下载地址：http://www.onlinedown.net/soft/577763.htm 11 windows版本的git工具下载地址：https://gitforwindows.org 12 SQLyog Ultimate V13.1.1 MySQL客户端工具破解版下载地址：https://www.jb51.net/database/645936.html 13 冰点文库下载器下载地址：http://www.bingdian001.com/?p=30 13 录屏和色素提取工具下载地址：https://faststone-capture.en.softonic.com 14 winrar解压缩工具破解版下载地址：https://www.win-rar.com/fileadmin/winrar-versions/sc20190304/wrr/winrar-x64-570sc.exe]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPC框架-Dubbo]]></title>
    <url>%2F2019%2F05%2F29%2FRPC%E6%A1%86%E6%9E%B6-Dubbo%2F</url>
    <content type="text"><![CDATA[官方描述Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 自我描述： dubbo是一个分布式的服务框架，用于分布式开发，就是服务调用，有很大的解耦性，实现方式就是把整个业务细颗粒拆分多个子模块，每个模块间通过dubbo相互调用实现。特性 面向接口代理的高性能RPC调用： 提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节。 智能负载均衡： 内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。 服务自动注册与发现： 支持多种注册中心服务，服务实例上下线实时感知。 高度可扩展能力： 遵循微内核+插件的设计原则，所有核心能力如Protocol、Transport、Serialization被设计为扩展点，平等对待内置实现和第三方实现。 运行期流量调度： 内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能。 可视化的服务治理与运维： 遵循微内核+提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。 文档官方文档]]></content>
      <categories>
        <category>RPC框架</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序开发（一）]]></title>
    <url>%2F2019%2F04%2F12%2Fminiprogram%2F</url>
    <content type="text"><![CDATA[小程序官方文档介绍首先附上文档：小程序官方文档介绍 可以说，现在每款智能手机上都装有一款微信软件，这款产品里面有各种功能，而微信也早已成为了一个生态。小程序其实就是基于微信平台的一款自封装的软件应用快速开发，扩展的一款东西。正如文档所说：微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。2017年1月9日，张小龙在2017微信公开课Pro上发布的小程序正式上线。经过将近两年的发展，小程序已经构造了自己的一套开发环境和开发者生态。小程序的开发内容也更是涵盖了许多的行业：房地产、内容咨询、新闻发布、科技创新、母婴家居、外卖物流、保险金融等各行各业。而小程序的开发也需要一定的技术功底。当然开发之前肯定是要注册一个小程序账号，小程序开放了个人和企业注册，方便了个人进行开发测试。不过，对于个人的开发有个比较大的坑，那就是小程序的云存储的权限问题：也就是说除创建者和管理员外，其他所有用户只有可读权限，并不能编辑他们自己的用户信息。不过可以使用wx.setStorage(Object object)来存储数据到本地，将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。当然，如果有自己的服务器，还是存在服务器数据库中最好。 好了，关于小程序就先说到这里。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3安装格式化json的插件]]></title>
    <url>%2F2018%2F11%2F06%2Fsublime-text3%2F</url>
    <content type="text"><![CDATA[sublime text 安装json格式化插件 第一步打开sublime text ,输入快捷键CTRL+`在下面输入：1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 第二步稍等几秒，等结束，然后用快捷键CTRL+shift+p，输入install package,选择第一个， 第三步等几秒，出现弹出框，在弹出框输入要安装的插件，等待安装完成。CTRL+alt+j格式化json]]></content>
  </entry>
  <entry>
    <title><![CDATA[github解决矛盾]]></title>
    <url>%2F2018%2F11%2F05%2Fgithub%E8%A7%A3%E5%86%B3%E7%9F%9B%E7%9B%BE%2F</url>
    <content type="text"><![CDATA[当从远程项目git clone 下来项目之后，然后进行二次开发，需要将代码提交到远程，处理流程： 工具git下载链接：git for windows 操作流程1.在项目目录打开gitbash2.输入git status查看状态3.输入git add将modified的文件需要提交的进行添加4.git commit -m “description”5.git fetch origin temp,将远程的代码拉取到temp临时分支里6.git merge temp，在当前master分支合并temp分支文件7.再次使用git status查看状态8.合并中会出现部分unmerged的文件，然后打开这些文件，手动解决冲突。9.冲突的同一个文件里的内容会有12345&lt;&lt;&lt;&lt;&lt;&lt;HEAD这里是你本地项目的代码====这里是从远程下下来的代码&gt;&gt;&gt;&gt;&gt;temp 看下哪里有冲突，手动解决后需要删除&lt;&lt;&lt;&lt;&lt;&lt;HEAD、====、&gt;&gt;&gt;&gt;&gt;temp这些多余的字符，至此冲突解决。然后正常的通过git add,git commit，git push [远程名] [本地分支]:[远程分支] 进行操作。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号授权]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[首先附上微信官方文档：https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842 授权登陆大致流程1.前端重定向到授权地址：12345var url = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot; + &quot;你的appid&quot; + &quot;&amp;redirect_uri=&quot; + &quot;你当前的页面地址，这个地址跟后台的域名回调地址的域名相同&quot; + &quot;&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE&amp;connect_redirect=1#wechat_redirect&quot;;# 重定向到微信授权地址window.location.href=url 注：redirect_uri：的地址所在域名需要在公众平台后台配置：如图： 2.获取微信返回到code，给后台传过去12345678910var url = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot; + &quot;你的appid&quot; + &quot;&amp;redirect_uri=&quot; + &quot;你当前的页面地址，这个地址跟后台的域名回调地址的域名相同&quot; + &quot;&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE&amp;connect_redirect=1#wechat_redirect&quot;;var codeUrl = location.search();if(codeUrl!=&quot;&quot;&amp;&amp; codeUrl!=null&amp;&amp;code.indexOf(&quot;code&quot;)!=-1)&#123;//此处就获得了code，具体代码自己写吧，就是截取字符串获取code参数&#125;else&#123;// 重定向到微信授权地址window.location.href=url&#125; 获取accesstoken如果报错：accesstoken invalid ip 55.11.11.10, not in whitelist此时需要在微信公众平台–&gt;基本配置–&gt;IP白名单设置此IP即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring mybatis整合]]></title>
    <url>%2F2018%2F08%2F05%2Fspring-mybatis%2F</url>
    <content type="text"><![CDATA[spring mvc+logback+mybatis整合日志和mysql日志打印web.xml配置123456789&lt;!-- 日志记录 --&gt;&lt;context-param&gt; &lt;!-- 日志配置文件路径 --&gt; &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:conf/logback.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;ch.qos.logback.ext.spring.web.LogbackConfigListener&lt;/listener-class&gt;&lt;/listener&gt; mybatis-config.xml配置12345678910111213&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt; &lt;/settings&gt; &lt;!-- 命名空间 --&gt; &lt;typeAliases&gt; &lt;/typeAliases&gt; &lt;!-- 映射map &lt;mappers&gt; &lt;/mappers&gt; --&gt;&lt;/configuration&gt; logback.xml配置12&lt;!--myibatis log configure 控制台输出语句--&gt;&lt;logger name=&quot;com.xx.xx.dao.*&quot; level=&quot;DEBUG&quot;/&gt; spring的声明式事务管理，可以回滚service的操作（当遇到异常情况时）12345678910111213141516171819202122Class Log&#123; Propagation.REQUIRED insertLog();&#125;Propagation.REQUIREDvoid saveDept()&#123; insertLog();//加入当前事务 ..异常部分 saveDept();&#125;Class LOg&#123; Propagation.REQUIRED_NEW insertLog();&#125; Propagation.REQUIREDvoid saveDept()&#123; insertLog();//始终开启事务 ..异常部分，日志不会回滚 saveDept();&#125; Aop(aspect object programming): 面向切面编程 功能：让关注点代码与业务代码分离！ 关注点: 重复代码就叫做关注点； 切面: 关注点形成的类，就叫切面(类). 面向切面编程，就是指对很多功能都有的重复的代码抽取，再在运行的时候往业务方法上动态植入“切面类代码”。 切入点: 执行目标对象方法，动态植入切面代码。可以通过切入点表达式，指定拦截哪些类的哪些方法；给指定的类在运行的时候植入切面类代码。(根据需要进行拦截,是否需要拦截)切入点表达式,可以对指定的“方法”进行拦截； 从而给指定的方法所在的类生层代理对象。 spring七大模块详解 spring 代理理解动态代理,用工厂类实现–需要实现接口123456789101112131415161.测试类 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;com/coffee/aop/bean.xml&quot;);/** * 动态代理（jdk代理） * * @throws Exception */@Testpublic void testAop() throws Exception &#123; // 调用工厂类,获取注解 IUserDao userDao = (IUserDao) ac.getBean(&quot;userDaoProxy&quot;); // 代理对象：class com.sun.proxy.$Proxy5 System.out.println(userDao.getClass()); userDao.save();&#125; 2.代理工厂类–用反射实现 1234567891011121314151617181920212223242526272829303132333435363738394041@Component(&quot;userDaoProxy&quot;)public class ProxyFactory &#123; private static Object target; private static Aop aop; public static Object getProxyInstance(Object target_, Aop aop_) &#123; target = target_; aop = aop_; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] objects) throws Throwable &#123; // 在核心业务代码执行前，，引入重复执行的代码 aop.begin(); Object returnValue = method.invoke(target, objects); // 核心代码结束后执行收尾工作 aop.commit(); return returnValue; &#125; &#125;); &#125;``` ## 动态代理--不需要使用工厂类,用注解1.dao层,加注解@Repository(&quot;userDao&quot;)``` @Repository(&quot;userDao&quot;)public class UserDao implements IUserDao &#123; public void save() &#123; // 获取session/处理异常--每次都要重复执行此类代码：被称为【关注点代码：就是重复执行的代码】 System.out.println(&quot;UserDao 核心业务代码：保存数据。。&quot;);// 这才是真正的核心业务代码：【关键点代码】 // 关闭session/处理异常--每次都要重复执行此类代码：【关注点代码：就是重复执行的代码】 &#125; 2.bean.xml 首先开启注解扫描 &lt;context:component-scan base-package=&quot;com.coffee.aop&quot;&gt;&lt;/context:component-scan&gt; 然后开启aop自动实现代理1234&lt;!-- 注解实现 aop编程 --&gt;&lt;!-- 1.在命名空间引入 aop相关头 --&gt;&lt;!-- 2.开启 aop注解 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; cglib代理:实现的cglib代理的类不能是finalcglib代理：需要引入spring-core.jar文件 1.测试类1234567891011121314/** * 注解代理:目标类没有实现接口，aop自动执行 cglib代理 * * @throws Exception */ @Test public void testCglibAop() throws Exception &#123; // 调用工厂类 OrderDao orderDao = (OrderDao) ac.getBean(&quot;orderDao&quot;); // 代理对象：class com.sun.proxy.$Proxy5 System.out.println(orderDao.getClass()); orderDao.save(); &#125; 2.dao层加注解123456// 将目标对象加入ioc@Repository(&quot;orderDao&quot;)public class OrderDao &#123;// 没有实现接口，使用cglib代理 public void save() &#123; System.out.println(&quot;OrderDao 核心业务代码：保存数据。。&quot;);// 这才是真正的核心业务代码：关键点代码 &#125; 3.bean.xml配置注解,开启aop 首先开启注解扫描 &lt;context:component-scan base-package=&quot;com.coffee.aop&quot;&gt;&lt;/context:component-scan&gt; 然后开启aop自动实现代理1234&lt;!-- 注解实现 aop编程 --&gt;&lt;!-- 1.在命名空间引入 aop相关头 --&gt;&lt;!-- 2.开启 aop注解 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; cglib底层实现12345678910111213141516171819public class ProxyFactory_cglib implements MethodInterceptor &#123; private Object target;// 维护代理对象 public ProxyFactory_cglib(Object target) &#123; this.target = target; &#125; // 给目标对象创建代理对象 public Object getProxyInstance() &#123; // 1. 工具类,在引入的jar文件中spring-core.jar Enhancer enhancer = new Enhancer(); // 2. 设置父类 enhancer.setSuperclass(target.getClass()); // 3. 设置回掉函数 enhancer.setCallback(this); // 4. 创建子类代理对象,,,,所以使用cglib代理的dao不能是final的 return enhancer.create(); &#125; 关注点代码&amp;&amp;关键点代码dao层12345public void save() &#123; // 获取session/处理异常--每次都要重复执行此类代码：被称为【关注点代码：就是重复执行的代码】 System.out.println(&quot;UserDao 核心业务代码：保存数据。。&quot;);// 这才是真正的核心业务代码：【关键点代码】 // 关闭session/处理异常--每次都要重复执行此类代码：【关注点代码：就是重复执行的代码】&#125; 切入点表达式 bean.xml:12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 定义一个切入点表达式 ,指定拦截哪些类的哪些方法--&gt; &lt;aop:pointcut expression=&quot;execution(* com.coffee.pointcut.*.*(..))&quot; id=&quot;pt&quot;/&gt;&lt;!-- 从这开始#######【下面是测试别的方法】######### --&gt; &lt;!-- 拦截所有的public方法--&gt; &lt;aop:pointcut expression=&quot;execution(public * *(..))&quot; id=&quot;pt&quot;/&gt; &lt;!-- 拦截所有的save方法--&gt; &lt;aop:pointcut expression=&quot;execution(* save*(..))&quot; id=&quot;pt&quot;/&gt; &lt;!-- 拦截指定类的指定的指定方法,具体到方法--&gt; &lt;aop:pointcut expression=&quot;execution(* com.coffee.pointcut.OrderDao.save(..))&quot; id=&quot;pt&quot;/&gt; &lt;!-- 拦截指定类的指定的所有方法,具体到类--&gt; &lt;aop:pointcut expression=&quot;execution(* com.coffee.pointcut.OrderDao.*(..))&quot; id=&quot;pt&quot;/&gt; &lt;!-- 拦截指定包，及其子包下的的所有类的所有方法 --&gt; &lt;aop:pointcut expression=&quot;execution(* com..*.*(..))&quot; id=&quot;pt&quot;/&gt; &lt;!-- 【多个表达式】 --&gt; &lt;!-- 拦截或的关系的方法，不能用and 或者&amp;&amp; --&gt; &lt;aop:pointcut expression=&quot;execution(* com.coffee.pointcut.OrderDao.save()) || execution (* com.coffee.pointcut.UserDao.save())&quot; id=&quot;pt&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(* com.coffee.pointcut.OrderDao.save(..))) || execution(* com.coffee.pointcut.UserDao.save())&quot; id=&quot;pt&quot;/&gt; &lt;!-- 取非值 --&gt; &lt;aop:pointcut expression=&quot;!execution(* com.coffee.pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt; &lt;!-- not 前要加空格，和上面等价 --&gt; &lt;aop:pointcut expression=&quot; not execution(* com.coffee.pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt;&lt;!-- 从这结束################ --&gt; &lt;!-- 切面配置 --&gt; &lt;aop:aspect ref=&quot;aop&quot;&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 前置通知 --&gt; &lt;aop:before method=&quot;begin&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 后置通知（最终通知） --&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 返回后通知 --&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 异常的通知 --&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; aop切面类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Aop &#123; public void begin() &#123; System.out.println(&quot;开始事务/异常&quot;); &#125; public void after() &#123; System.out.println(&quot;提交事务/关闭&quot;); &#125; public void afterReturning() &#123; System.out.println(&quot;afterReturning()&quot;); &#125; // 目标方法异常处理 public void afterThrowing() &#123; System.out.println(&quot;afterThrowing()&quot;); &#125; public void around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;环绕前执行。。相当于@Before()&quot;); pjp.proceed(); System.out.println(&quot;还绕后执行。。相当于@After()&quot;); &#125;&#125;// 事务传播的属性@Servicepublic class T_DeptService &#123; @Resource // 加入容器 T_DeptDao t_DeptDao = new T_DeptDao(); @Resource LogsDao logsDao = new LogsDao(); // 事务传播的属性 @Transactional( // readOnly = false, // timeout = -1, // noRollbackFor = ArithmeticException.class 遇到异常不回滚 // propagation=Propagation.REQUIRED Propagation.REQUIRED // 指定当前的方法必须在事务的环境下执行； // 如果当前运行的方法，已经存在事务， 就会加入当前的事务，受当前事务约束； // Propagation.REQUIRED_NEW // 指定当前的方法必须在事务的环境下执行； // 如果当前运行的方法，已经存在事务： 事务会挂起（就像遇到异常不回滚此方法）； 会始终开启一个新的事务，执行完后； 刚才挂起的事务才继续运行。 ) // 必须加上这个注解才能实现注解的spring事务控制，这个注解可以加载类上，父类上，范围范围根据加在什么上面而不同 public void save(T_Dept t_Dept) &#123; logsDao.insertlog(); int i = 1 / 0;// 模拟中间的异常,配置spring事务控制后遇到异常就会回滚，即上面的数据库操作无效 t_DeptDao.save(t_Dept); &#125;&lt;!-- 1.【c3p0连接池 数据源配置(oracle)】 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;wangan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;666&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;3&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxStatements&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot; value=&quot;2&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.【数据库模板】 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; pring声明式事务管理1234567891011121314151617181920&lt;!-- ####5. spring声明式事务管理器### --&gt;&lt;!-- 1. 配置事务管理器类 --&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2. 配置事务增强 ，如何管理事务--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 以get开头/find开头的所有方法只读，剩下的读写 --&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;false&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 3. 配置aop，拦截哪些方法(切入点表达式)+应用上面的事务增强 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.coffee.spring_transaction.T_DeptService.*(..))&quot; /&gt;&lt;!-- (..)带上两个点;第一个*式返回值类型 --&gt; &lt;!-- 引入切入点表达式 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot; /&gt;&lt;/aop:config&gt; mybatis中的sqlsession工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package utils;import java.io.IOException;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;/** * 加载mybatis配置文件 * @author wangan * */public class MybatisUtil &#123; // 本地线程,用于绑定session,,SqlSession是mybatis里面的创建session的类,hibernate是session private static ThreadLocal&lt;SqlSession&gt; threadLocal = new ThreadLocal&lt;SqlSession&gt;(); private static SqlSessionFactory sqlSessionFactory; // 私有化无参构造,防止人为不断new他 private MybatisUtil() &#123; &#125; // 使用static静态块的好处就是加载快,只能加载一次 static &#123; try &#123; // 加载src/mybatis.xml Reader reader = Resources.getResourceAsReader(&quot;mybatis.xml&quot;); // 加载reader,创建sqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /** * 返回session */ public static SqlSession getSqlSession() &#123; SqlSession sqlSession = threadLocal.get(); if (sqlSession == null) &#123; sqlSession = sqlSessionFactory.openSession(); // 本地线程绑定sqlsession threadLocal.set(sqlSession); &#125; return sqlSession; &#125; /** * 关闭session */ public static void closeSqlSession() &#123; SqlSession sqlSession = threadLocal.get(); if (sqlSession != null) &#123; // 关闭session sqlSession.close(); // 移除session,供GC回收,不然多次访问数据库后会变慢 threadLocal.remove(); &#125; &#125;&#125; 映射配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace随便起名字 --&gt;&lt;mapper namespace=&quot;studentNamespace&quot;&gt; &lt;!-- type=&quot;com.coffee.mybatis01.entity.Student&quot;名字太长,用别名在mybatis配置文件配置 id属性用来标记resultmap,如果实体类中的属性和表的字段不一致,用id 如果都一致,可选 --&gt; &lt;resultMap type=&quot;student&quot; id=&quot;student&quot;&gt; &lt;!-- 主键映射 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;!-- 其他属性映射 --&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;sal&quot; column=&quot;sal&quot;/&gt; &lt;/resultMap&gt; &lt;!-- StudentDao里面的add方法，就是插入方法名称（理论上随便起，方便理解就用一样的名字） parameterType方法的参数的类型，写全路径 --&gt; &lt;!-- 无参插入( parameterType=&quot;com.coffee.mybatis01.entity.Student&quot;省略) --&gt; &lt;insert id=&quot;add1&quot; &gt; &lt;!-- 插入的sql语句 --&gt; insert into students values(1,&apos;张三&apos;,7000) &lt;/insert&gt; &lt;!-- 带参插入 --&gt; &lt;insert id=&quot;add2&quot; parameterType=&quot;student&quot;&gt; &lt;!-- 插入的sql语句 #&#123;id&#125;==student.getId(),是占位符的意思,hibernate是:= --&gt; insert into students values(#&#123;id&#125;,#&#123;name&#125;,#&#123;sal&#125;) &lt;/insert&gt; &lt;!-- 修改值 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;student&quot;&gt; update students set name=#&#123;name&#125;,sal=#&#123;sal&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- 查询所有 resultType返回的是集合,但是我就是要遍历出来student,所以只写student类型 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;student&quot;&gt; select * from students &lt;/select&gt; &lt;!-- 根据id查询 resultMap映射resultMap里的id,代表返回值类型,根据id的类型进行返回值判断,resultType比较精确,resultMap是通用的 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultMap=&quot;student&quot;&gt; select * from students where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 删除数据 --&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from students where id=#&#123;id&#125; &lt;/delete&gt; &lt;!-- ###分页操作 --&gt; &lt;!-- 无条件分页 --&gt; &lt;select id=&quot;findPage&quot; resultMap=&quot;student&quot;&gt; select * from students where id between #&#123;start&#125; and #&#123;end&#125; &lt;/select&gt; &lt;!-- 动态sql查询 --&gt; &lt;select id=&quot;dynaSelect&quot; parameterType=&quot;map&quot; resultMap=&quot;student&quot;&gt; select * from students &lt;where&gt; &lt;!-- kid是map的Key键,test自动判断key值 --&gt; &lt;if test=&quot;pid!=null&quot;&gt; and id=#&#123;pid&#125; &lt;/if&gt; &lt;if test=&quot;pname!=null&quot;&gt; and name=#&#123;pname&#125; &lt;/if&gt; &lt;if test=&quot;psal!=null&quot;&gt; and sal=#&#123;psal&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 动态sql update更新 name=#&#123;name&#125;,不要忘了逗号&apos;,&apos; --&gt; &lt;update id=&quot;dynaUpdate&quot; parameterType=&quot;student&quot;&gt; update students &lt;set&gt; &lt;if test=&quot;name!=null&quot;&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt; sal=#&#123;sal&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- 动态sql删除多个#迭代数组 --&gt; &lt;delete id=&quot;dynaDelete&quot;&gt; &lt;!-- 删除多个需要遍历数组(这里是数组的遍历array) 完整的sql是: delete from students where id in (1,3,5) collection遍历的类型:array/list open开头 close结尾 item遍历的名称,可以任意写,不需要和dao的一致 separator分隔符,分割数组的内容 #&#123;ids&#125;和item的一致 --&gt; delete from students where id in &lt;foreach collection=&quot;array&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;ids&quot;&gt; #&#123;ids&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;!-- 动态sql删除多个,迭代list --&gt; &lt;delete id=&quot;dynaDeleteList&quot;&gt; delete from students where id in &lt;foreach collection=&quot;list&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;list&quot; separator=&quot;,&quot;&gt; #&#123;list&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;!-- #### 动态插入对象 #######--&gt; &lt;!-- insert into students (id,name,value) values (1,&quot;张三&quot;,5000.0) --&gt;&lt;!-- &lt;sql id=&quot;key&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt;id,&lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt;name,&lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt;sal&lt;/if&gt; &lt;/sql&gt; &lt;sql id=&quot;value&quot;&gt; trim标签可以去掉,同时把#&#123;sal&#125;,的逗号去掉 &lt;trim suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt;#&#123;id&#125;,&lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt;#&#123;name&#125;,&lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt;#&#123;sal&#125;,&lt;/if&gt; &lt;/trim&gt; &lt;/sql&gt; &lt;insert id=&quot;dynaInsert&quot;&gt; insert into students (&lt;include refid=&quot;key&quot;&gt;&lt;/include&gt;) values(&lt;include refid=&quot;value&quot;&gt;&lt;/include&gt;) &lt;/insert&gt; --&gt; &lt;!-- 效果同上,都可以插入 --&gt; &lt;insert id=&quot;dynaInsert&quot;&gt; insert into students (id,name,sal) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;sal&#125;) &lt;/insert&gt;&lt;/mapper&gt; dao调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261package com.coffee.mybatis01.dao;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.apache.ibatis.session.SqlSession;import utils.MybatisUtil;import com.coffee.mybatis01.entity.Student;/** * 数据访问层 * @author wangan * */public class StudentDao &#123; /** * 添加学生--无参 * @param student */ public void add1() throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); sqlSession.insert(&quot;studentNamespace.add1&quot;); try &#123; sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚操作 sqlSession.rollback(); throw new RuntimeException(e); &#125; finally &#123; MybatisUtil.closeSqlSession(); &#125; &#125; /** * 添加学生--有参 * @param student */ public void add2(Student student) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); // 插入对象,指定映射空间名称,和&lt;insert&gt;标签的id try &#123; sqlSession.insert(&quot;studentNamespace.add2&quot;, student); &#125; catch (Exception e) &#123; sqlSession.rollback(); throw new RuntimeException(e); &#125; finally &#123; sqlSession.commit(); MybatisUtil.closeSqlSession(); &#125; &#125; /** * 修改学生 * @param student */ public void update(Student student) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; sqlSession.update(&quot;studentNamespace.update&quot;, student); &#125; catch (Exception e) &#123; sqlSession.rollback(); &#125; finally &#123; sqlSession.commit(); MybatisUtil.closeSqlSession(); &#125; &#125; /** * 查询所有学生 * @param student */ public List&lt;Student&gt; findAll() throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); try &#123; studentList = sqlSession.selectList(&quot;studentNamespace.findAll&quot;); &#125; catch (Exception e) &#123; sqlSession.rollback(); &#125; finally &#123; sqlSession.commit(); MybatisUtil.closeSqlSession(); &#125; return studentList; &#125; /** * 根据id查询学生 * @param student */ public Student findById(int id) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); Student student = new Student(); try &#123; student = sqlSession.selectOne(&quot;studentNamespace.findById&quot;, id); sqlSession.commit(); &#125; catch (Exception e) &#123; sqlSession.rollback(); &#125; finally &#123; MybatisUtil.closeSqlSession(); &#125; return student; &#125; /** * 删除学生 * @param student */ public void delete(int id) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; sqlSession.delete(&quot;studentNamespace.delete&quot;, id); sqlSession.commit(); &#125; catch (Exception e) &#123; sqlSession.rollback(); &#125; finally &#123; MybatisUtil.closeSqlSession(); &#125; &#125; /** * 分页查询--无条件 */ public List&lt;Student&gt; findPage(int start, int end) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); try &#123; Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); map.put(&quot;start&quot;, start); map.put(&quot;end&quot;, end); students = sqlSession.selectList(&quot;studentNamespace.findPage&quot;, map); sqlSession.commit(); &#125; catch (Exception e) &#123; sqlSession.rollback(); &#125; finally &#123; MybatisUtil.closeSqlSession(); &#125; return students; &#125; /** * 动态sql查询--参数使用包装类型进行条件判断时如果是null代表不限,不确定,任意 */ public List&lt;Student&gt; dynaSelect(Integer id, String name, Double sal) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); try &#123; Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); map.put(&quot;pid&quot;, id); map.put(&quot;pname&quot;, name); map.put(&quot;psal&quot;, sal); list = sqlSession.selectList(&quot;studentNamespace.dynaSelect&quot;, map); &#125; catch (Exception e) &#123; sqlSession.rollback(); throw new RuntimeException(e); &#125; finally &#123; MybatisUtil.closeSqlSession(); &#125; return list; &#125; /** * 动态sql更新 */ public void dynaUpdate(Student student) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; sqlSession.update(&quot;studentNamespace.dynaUpdate&quot;, student); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125; finally &#123; sqlSession.commit(); MybatisUtil.closeSqlSession(); &#125; &#125; /** * 动态sql迭代数组--根据id删除多个 */ public void dynaDelete(int... ids) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; sqlSession.delete(&quot;studentNamespace.dynaDelete&quot;, ids); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125; finally &#123; sqlSession.commit(); MybatisUtil.closeSqlSession(); &#125; &#125; /** * 动态sql迭代list集合--根据id删除多个 */ public void dynaDeleteList(List&lt;Integer&gt; list) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; sqlSession.delete(&quot;studentNamespace.dynaDeleteList&quot;, list); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125; finally &#123; sqlSession.commit(); MybatisUtil.closeSqlSession(); &#125; &#125; /** * 动态sql插入对象 */ public void dynaInsert(Student student) throws Exception &#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); try &#123; sqlSession.insert(&quot;studentNamespace.dynaInsert&quot;, student); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125; finally &#123; sqlSession.commit(); MybatisUtil.closeSqlSession(); &#125; &#125;&#125; 整合之注册功能spring.xml配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;!-- 1. 配置c3p0连接池 --&gt; &lt;bean id=&quot;comboPooledDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;wangan&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;666&quot;/&gt; &lt;/bean&gt; &lt;!-- 2. 配置sqlsession代替原生mybatisUtil工具类 --&gt; &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 加载配置文件mybatis.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt; &lt;!-- 引入数据资源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;comboPooledDataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 3. mybatis事务管理器,底层用的是jdbc --&gt; &lt;bean id=&quot;dataSourceTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 引入数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;comboPooledDataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 4. 配置事物通知,如何管理事物 --&gt; &lt;tx:advice id=&quot;tx&quot; transaction-manager=&quot;dataSourceTransactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- REQUIRED默认,在有事物情况下执行,没有事物就创建新的事物 propagation=&quot;REQUIRED&quot; 默认 read-only=&quot;false&quot; 默认 --&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 5.配置事物切面aop,拦截哪些方法 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.coffee.dao.*.*(..))&quot; id=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;tx&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; &lt;!-- 注册dao --&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.coffee.dao.StudentDao&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactoryBean&quot;/&gt; &lt;/bean&gt; &lt;!-- 注册service --&gt; &lt;bean name=&quot;studentService&quot; class=&quot;com.coffee.service.StudentService&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册action(注解),里面有service,service加了注解,扫描 --&gt; &lt;context:component-scan base-package=&quot;com.coffee&quot;/&gt; &lt;!-- 通知springioc注解作用 --&gt; &lt;context:annotation-config /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; dao123456789101112131415161718192021222324252627282930313233package com.coffee.dao;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import com.coffee.entity.Student;/** * 数据访问--StudentDao * @author wangan * */public class StudentDao &#123; // 注入sqlsession工厂 private SqlSessionFactory sqlSessionFactory; public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; this.sqlSessionFactory = sqlSessionFactory; &#125; /** * 添加学生 * @param student * @throws Exception */ public void add(Student student) throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.insert(&quot;studentNamespace.add&quot;, student); sqlSession.close(); &#125;&#125; service12345678910111213141516171819202122232425262728package com.coffee.service;import com.coffee.dao.StudentDao;import com.coffee.entity.Student;/** * 数据访问 * @author wangan * */public class StudentService &#123; private StudentDao studentDao; public void setStudentDao(StudentDao studentDao) &#123; this.studentDao = studentDao; &#125; public void register(Student student) throws Exception &#123; try &#123; studentDao.add(student); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Action12345678910111213141516171819202122232425262728293031323334353637383940414243package com.coffee.action;import javax.annotation.Resource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import com.coffee.entity.Student;import com.coffee.service.StudentService;/** * action * @author wangan * */@Controller@RequestMapping(value = &quot;/student&quot;)public class StudentAction &#123; private StudentService studentService; @Resource(name = &quot;studentService&quot;) public void setStudentService(StudentService studentService) &#123; this.studentService = studentService; &#125; /** * 注册学生 * @param student * @return */ @RequestMapping(value = &quot;/register&quot;) public String registerStudent(Student student) &#123; try &#123; studentService.register(student); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return &quot;success&quot;; &#125;&#125; test1234567891011121314151617181920212223242526272829package test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.coffee.dao.StudentDao;import com.coffee.entity.Student;/** * 测试整合 * @author wangan * */public class TestSpring_mybatis &#123; public static void main(String[] args) &#123; Student student = new Student(20, &quot;王林&quot;, 8000d); ApplicationContext ac = new ClassPathXmlApplicationContext( new String[] &#123; &quot;spring.xml&quot; &#125;); StudentDao studentDao = (StudentDao) ac.getBean(&quot;studentDao&quot;); try &#123; studentDao.add(student); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; web.xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;sshProject2&lt;/display-name&gt;&lt;!-- struts2 配置 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- spring配置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:bean.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;&lt;!-- 服务器启动时自动装配spring的配置bean.xml --&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;/web-app&gt; struts.xml12345678910111213&lt;!-- 拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name=&quot;userInterceptor&quot; class=&quot;com.coffee.action.UserInterceptor&quot;&gt;&lt;/interceptor&gt; &lt;interceptor-stack name=&quot;myStack&quot;&gt; &lt;!-- 配置struts2框架运行时，默认执行自定义拦截器栈 --&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; &lt;!-- 应用自定义拦截器 --&gt; &lt;interceptor-ref name=&quot;userInterceptor&quot;&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 执行指定的拦截器 --&gt; &lt;default-interceptor-ref name=&quot;myStack&quot;&gt;&lt;/default-interceptor-ref&gt; UserInterceptor.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.coffee.action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;/** * 管理员拦截器 * 较验用户是否登陆，只有登陆后才可以进行操作。 * 没有登陆，只能查看列表，不能操作！ * @author wangan * */@SuppressWarnings(&quot;all&quot;)public class UserInterceptor extends AbstractInterceptor &#123; @Override // 所有的拦截器都会调用此方法 public String intercept(ActionInvocation invocation) throws Exception &#123; // 1.得到当前执行的方法--代理获取方法 String methodName = invocation.getProxy().getMethod(); // 2.得到actionContext对象 ActionContext context = invocation.getInvocationContext(); // 3.获取session，从session获取登录用户对象 Object object = context.getSession().get(&quot;adminInfo&quot;); // 4.判断方法是否放行，登录方法放行 if (!&quot;login&quot;.equals(methodName) &amp;&amp; !&quot;list&quot;.equals(methodName)) &#123; if (object == null) &#123; // 没有登录 return &quot;login&quot;; &#125; else &#123; // 执行action ,放行 return invocation.invoke(); &#125; &#125; else &#123; // 允许访问登录/列表展示 return invocation.invoke(); &#125; &#125;&#125; 数据回显1234567891011121314151617181920212223/** * 3. 修改员工-进入修改页面(list.jsp里面的修改 链接跳转到这里) * struts2的保存修改数据的方式就是模型驱动，先把旧的数据移除，新的压进栈 */public String viewUpdate() &#123;// 更新一条记录的关键步骤 // 1.获取主键 int id = employee.getEmployeeId(); // 2.根据员工的主键查询，此时已经有部门信息（lazy=false） Employee employee = employeeService.findById(id); // 3. 查询所有的部门信息 List&lt;Dept&gt; listDept = deptService.getAll(); // 4.数据回显 // 获取valueStack对象 ValueStack valueStack = ActionContext.getContext().getValueStack(); // 移除栈顶元素（旧的） valueStack.pop(); // 入栈，即将更新的值 valueStack.push(employee); request.put(&quot;listDept&quot;, listDept); return &quot;edit&quot;;&#125; 下拉列表1234&lt;td&gt; &lt;!-- name=&quot;deptId&quot;随便取，代表下拉列表名字 --&gt; &lt;s:select list=&quot;#request.listDept&quot; listKey=&quot;deptId&quot; listValue=&quot;deptName&quot; name=&quot;deptid&quot; headerKey=&quot;-1&quot; headerValue=&quot;请选择&quot; value=&quot;-1&quot;&gt;&lt;/s:select&gt;&lt;/td&gt; 做注册的时候员工的信息联系到另外一张表部门表,下拉菜单选择部门的时候这个deptid顺带传过去提交到注册action1234567891011121314151617181920212223// 封装部门id，下拉列表里面的name=“deptid”的值 private int deptid; public void setDeptid(int deptid) &#123; this.deptid = deptid; &#125; public int getDeptid() &#123; return deptid; &#125;//注册public String save() &#123; // 先根据部门主键查询 Dept dept = deptService.findById(deptid); // 部门设置到员工对象中 employee.setDept(dept); // 保存员工 employeeService.save(employee); return &quot;listAction&quot;;// 重定向到Action &#125; mybatis工作流程:1️⃣ 通过Reader对象读取src目录下面的mybatis.xml配置文件(可自定义路径)2️⃣ 通过SqlSessionBuilder对象创建SqlSessionFactory对象3️⃣ 从当前线程中获取SqlSession对象4️⃣ 事物开始,在mybatis中默认5️⃣ 通过SqlSession对象读取StudentMapper.xml映射文件中的操作编号,从而读取sql语句6️⃣ 事物必须提交7️⃣ 关闭SqlSession对象.并且分开当前线程与SqlSession对象,让GC尽早回收 批量插入数据–list集合1234567891011121314151617181920212223242526272829&lt;insert id=&quot;insertList&quot;&gt;INSERT INTO BUY_ORDER_DETAIL (BOD_ID, GOODS_ID, GOODS_NAME,GOODS_UNIT, GOODS_TYPE, GOODS_COLOR,BOD_AMOUNT, BOD_BUY_PRICE, BOD_TOTAL_PRICE,BO_ID, BOD_IMEI_LIST)&lt;foreach close=&quot;)&quot; collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;union&quot;&gt;SELECT#&#123;item.bodId,jdbcType=VARCHAR&#125;, #&#123;item.goodsId,jdbcType=VARCHAR&#125;,#&#123;item.goodsName,jdbcType=VARCHAR&#125;,#&#123;item.goodsUnit,jdbcType=VARCHAR&#125;,#&#123;item.goodsType,jdbcType=VARCHAR&#125;, #&#123;item.goodsColor,jdbcType=VARCHAR&#125;,#&#123;item.bodAmount,jdbcType=DECIMAL&#125;, #&#123;item.bodBuyPrice,jdbcType=DECIMAL&#125;,#&#123;item.bodTotalPrice,jdbcType=DECIMAL&#125;, #&#123;item.boId,jdbcType=VARCHAR&#125;,#&#123;item.bodImeiList,jdbcType=CLOB&#125;FROM DUAL&lt;/foreach&gt;&lt;/insert&gt;&lt;!-- 分页查询商品,动态sql --&gt;&lt;select id=&quot;selectPageListUseDys&quot; parameterType=&quot;goods&quot; resultMap=&quot;goodsResultMap&quot;&gt;SELECT * FROM (SELECT ROWNUM RN,GO.* FROM(SELECT * FROM GOODS&lt;where&gt;&lt;if test=&quot;paramEntity.goodsName!=null&quot;&gt;AND GOODS_NAME LIKE #&#123;paramEntity.goodsName&#125;&lt;/if&gt;&lt;/where&gt;ORDER BY GOODS_ID)GOWHERE ROWNUM &amp;lt;= #&#123;start&#125;+#&#123;rows&#125;)WHERE RN &amp;gt; #&#123;start&#125;&lt;/select&gt; 错误例2：将整个sql语句用&lt;![CDATA[ ]]&gt; 标记来避免冲突，在一般情况下都是可行的，是由于该sql配置中有动态语句（where部分），将导致系统无法识别动态判断部分，导致整个sql语句非法。12345678&lt;select id=&quot;find&quot; parameterClass=&quot;java.util.Map&quot; resultClass=&quot;java.lang.Long&quot;&lt;![CDATA[ select id from tableA a,tableB b &lt;dynamic prepend=&quot;WHERE&quot;&gt; &lt;isNotNull prepend=&quot;AND&quot; property=&quot;startDate&quot;a.act_time &gt;= #startDate# and a.act_time &lt;= #endDate# and a.id = b.id &lt;/isNotNull&gt;&lt;/dynamic&gt; ]]&gt; &lt;/select&gt; 正确做法：缩小范围，只对有字符冲突部分进行合法性调整。&lt;select id=&quot;find&quot; parameterClass=&quot;java.util.Map&quot; resultClass=&quot;java.lang.Long&quot;&gt; select ifrom tableA a, tableB b &lt;dynamic prepend=&quot;WHERE&quot;&gt; &lt;isNotNull prepend=&quot;AND&quot; property=&quot;startDate&quot;&gt; a.act_time &gt;= #startDate# &lt;![CDATA[ and a.act_time &lt;= #endDate# ]]&gt; and a.id = b.id &lt;/isNotNull&gt; &lt;/dynamic&gt; &lt;/select&gt; 1234567ibatis中应该经常见到&lt;![CDATA[这样的东西吧，它的用处应该是转义一些特殊关键字字符，不合法的XML字符必须被替换为相应的实体。 下面是五个在XML文档中预定义好的实体: &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;amp; &amp; 和 &amp;apos; &apos; 单引号 &amp;quot; &quot; 双引号]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu使用lantern翻墙]]></title>
    <url>%2F2018%2F07%2F23%2Flantern%2F</url>
    <content type="text"><![CDATA[Ubuntu蓝灯下载地址https://raw.githubusercontent.com/getlantern/lantern-binaries/master/lantern-installer-64-bit.deb 第一步设置网络代理 第二步 一般打开蓝灯会自动进行设置手动代理，如果不是手动代理，最好设置一下]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>lantern</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-svn简述]]></title>
    <url>%2F2018%2F06%2F21%2Fgit-svn%2F</url>
    <content type="text"><![CDATA[SVNSVN是Subversion的简称，是一个开放源代码的版本控制系统,支持大多数常见的操作系统。作为一个开源的版本控制系统,Subversion管理着随时间改变的数据。这些数据放置在一个中央资料档案库(repository)中。这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动。这样你就可以把档案恢复到旧的版本,或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件,其中包括了程序源码。 集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。下面举例说明：工作流程： 1从服务器下载项目组最新代码。2进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯。因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。3下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。 GIT（分布式版本控制系统）Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库. Git的功能特性：从一般开发者的角度来看，git有以下功能： 从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。 在自己的机器上根据不同的开发目的，创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。 生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。 一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。 从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能： 查看邮件或者通过其它方式查看一般开发者的提交状态。 打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。 向公共服务器提交结果，然后通知所有开发人员。 区别 SVN属于集中化的版本控制系统，有个不太精确的比喻:SVN = 版本控制+ 备份服务器 SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。 Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。 GIT跟SVN一样有自己的集中式版本库或服务器。但，GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，电梯里等，你仍然能够提交文件，查看历史版本记录，创建项目分支，等。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。 GIT把内容按元数据方式存储，而SVN是按文件所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。 分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。然而，处理GIT的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。 GIT没有一个全局的版本号，而SVN有目前为止这是跟SVN相比GIT缺少的最大的一个特征。你也知道，SVN的版本号实际是任何一个相应时间的源代码快照。我认为它是从CVS进化到SVN的最大的一个突破。因为GIT和SVN从概念上就不同，我不知道GIT里是什么特征与之对应。如果你有任何的线索，请在评论里奉献出来与大家共享。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 优缺点SVN 的优缺点SVN对中文支持好，操作简单，使用没有难度，美工人员，产品人员，测试人员，实施人员都可轻松上手。使用界面统一，功能完善，操作方便。 Git的优缺点对程序源代码进行差异化的版本管理，代码库占极少的空间。易于代码的分支化管理。不支持中文，图形界面支持差，使用难度大。不易推广。适用范围：1适用对象不同。Git适用于参与开源项目的开发者。他们由于水平高，更在乎的是效率而不是易用性。SVN则不同，它适合普通的公司开发团队。使用起来更加容易。 2使用的场合不同。Git适用于通过Internet，有多个开发角色的单个项目开发，SVN适合企业内部由项目经理统一协调的多个并行项目的开发。 3权限管理策略不同。Git没有严格的权限管理控制，只要有帐号，就可以导出、导入代码，甚至执行回退操作。SVN则有严格的权限管理，可以按组、按个人进行针对某个子目录的权限控制。区分读、写权限。更严格的，不支持回退操作。保证代码永远可以追踪。 4分支(branch)的使用范围不一样。Git中，你只能针对整个仓库作branch,而且一旦删除，便无法恢复。而SVN中，branch可以针对任何子目录，它本质上是一个拷贝操作。所以，可以建立非常多、层次性的branch,并且，在不需要时将其删除，而以后需要时只要checkout老的SVN版本就可以了。 5基于第三点，Git适用于单纯的软件项目，典型的就是一些开源项目，比如Linux内核、busybox等。相反，SVN擅长多项目管理。比如，你可以在一个SVN仓库中存放一个手机项目的bsp/设计文档/文件系统/应用程序/自动化编译脚本，或者在一个SVN中存放5款手机项目的文件系统。git中必须建立n(项目数)*m（组件数）个仓库。SVN中只需要最多n或者m个就可以了。 6Git使用128位ID作为版本号，而且checkout时要注明是哪个branch,而SVN使用一个递增的序列号作为全局唯一的版本号，更加简明易懂。虽然可以使用gittag来建立一些文字化的别名，但是毕竟那只是针对特殊版本。 7可跟踪性，git的典型开发过程为：建立分支，进行开发，提交到本地master，删除分支。这样做的后果是以前的修改细节会丢失。而在SVN下做同样的事情，不会丢失任何细节。这里是一个有趣的链接，表明了git下典型的工作方式：（以master为核心，不断创建新branch,删除旧branch): 8局部更新，局部还原。SVN由于是在每个文件夹建立一个.svn文件夹来实现管理，所以可以很简单实现局部更新或者还原。假如你只希望更新某些部分，则svn可以很好实现。同时代码写错了，同时可以很好实现局部还原，当然git也可以通过历史版本还原，但是无法简单地实现局部还原。 SVN属于集中化的版本控制系统这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。 Subversion的特点概括起来主要由以下几条：1每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；2获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；3提交必须有网络连接（非本地版本库）；4提交需要授权，如果没有写权限，提交会失败；5提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；6冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。 Git属于分布式的版本控制系统自2005年诞生于以来，Git日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。与SVN不同，Git记录版本历史只关心文件数据的整体是否发生变化。Git并不保存文件内容前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git不会再次保存，而只对上次保存的快照作一连接。]]></content>
      <categories>
        <category>github-svn</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲整]]></title>
    <url>%2F2018%2F06%2F16%2Fthank%2F</url>
    <content type="text"><![CDATA[今天终于可以把博客重新翻新一遍了，之前的next主题的配置不是那么好看，自己有有强迫症。所以重新在网上学习了一遍相关配置，同时也借鉴的很多大佬的博文，也收藏了很多文章，从中获益不少，有的文章甚至看了好几次才看出来，可能是我有点笨笨滴吧😝。不过还好坚持下来了，也做到了自己认为比较好的结果。 写一句话来激励自己：You’re far more powerful than you think ✊. 优质大佬博客推荐阅读： https://reuixiy.github.io http://cherryblog.site http://xiaweizi.cn https://notes.wanghao.work 本人简书和掘金地址，后续会不断推出优质文章： https://www.jianshu.com/u/6da361269696 https://juejin.im/user/59b55715f265da064d3454a5]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo增加live2d看板宠物动画]]></title>
    <url>%2F2018%2F06%2F12%2Flive2d%2F</url>
    <content type="text"><![CDATA[首先贴出官网代码官网地址配置：https://www.npmjs.com/package/hexo-helper-live2d 按如下步骤执行1️⃣ 首先检查博客主目录下面的 package.json里是否有 &quot;hexo-helper-live2d&quot;: &quot;^3.0.3&quot;,依赖，有的话可以先卸载使用命令：npm uninstall hexo-helper-live2d之后再安装：npm install --save hexo-helper-live2d 命令都是在你的博客主目录执行 安装完成之后在package.json会看到安装的model此时再去 node_moduels目录下，可以看到有如下文件夹，这些都是动画主配置2️⃣ 下载各种动画model：地址：https://github.com/xiazeyu/live2d-widget-models.git 3️⃣ 下载好之后将packages里的所有动画模板拷贝到博客的node_modules目录里 4️⃣ 配置博客站点配置文件，_config.yml1234567891011live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 5️⃣ 开始部署当使用hexo clean或者 hexo g命令的时候，这时候就可以看到如下日志了1INFO HEXO-HELPER-LIVE2D: Loaded model from npm-module(1), live2d-widget-model-epsilon2_1@1.0.5 from &apos;D:\github\blog\node_modules\live2d-widget-model-epsilon2_1\assets&apos; 说明已经加载到了配置的动画模板，到此就完成了。 原创，转载请注明出处。推荐阅读： https://juejin.im/user/59b55715f265da064d3454a5 https://www.jianshu.com/u/6da361269696]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>live2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github配置ssh]]></title>
    <url>%2F2018%2F04%2F12%2Fgithub-ssh%2F</url>
    <content type="text"><![CDATA[git命令窗口输入123$ git config --global user.name &quot;wangan058&quot;$ git config --global user.email &quot;wangan058@163.com&quot;$ ssh-keygen -t rsa -C &quot;wangan058@163.com&quot; 然后生成一个C:\Users\annkee(你的用户目录)\.ssh路径，打开id_rsa.pub文件，复制全部粘贴到远端的github上的ssh key 里面。 测试：$ ssh -T git@github.com 出现:Hi annkee! You&#39;ve successfully authenticated, but GitHub does not provide shell access.sh 说明正常 在你init过的路径下进入“.git目录”，打开“config”文件，修改url为：12url = git@github.com:annkee/mobile-scm.gitfetch = +refs/heads/*:refs/remotes/origin/* 把https://github.com/ 替换为 git@github.com: 就行了]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构、框架、模式、模块、组件、插件、控件、中间件的含义和区别]]></title>
    <url>%2F2018%2F04%2F05%2Fdiff%2F</url>
    <content type="text"><![CDATA[软件架构（architecture）英文：Architecture is the art of planning, designing, and constructing buildings.中文：软件架构，也称为软件体系结构。简单地说，软件架构就是一个蓝图，是一种设计方案，将客户的不同需求抽象成为抽象组件，并且能够描述这些抽象组件之间的通信和调用。它是对软件系统的系统组织，是对构成系统的构件的接口，行为模式，协作关系等体系问题的决策总和。它不仅涉及到结构与行为，而且还涉及到系统的使用，功能，性能，适应性，重用性，可理解性，经济性和技术约束的权衡和美学考虑。 使用方法：软件架构会分析工程中的问题，针对问题设计解决方案，针对解决方案分析应具有的功能，针对功能设计软件系统的层次和模块及层次模块之间的逻辑交互关系，确定各个功能如何由这些逻辑实现。工程开发者，可以根据软件架构中分析出来的层次和模块进行软件的编写。 软件框架（framework）英文：A framework is a structure that forms a support or frame for something. A structure is something that consists of parts connected together in an ordered way. A framework is a set of classes that embodies an abstract design for solutions to a family of related problems, and supports reuses at a larger granularity than classes.A software framework provides the skeleton of an application that can be customized by an application developer.中文：软件框架是项目软件开发过程中提取特定领域软件的共性部分形成的体系结构，不同领域的软件项目有着不同的框架类型。框架不是现成可用的应用系统，而是一个半成品，是一个提供了诸多服务，供开发人员进行二次开发，实现具体功能的应用系统。特别强调，框架是一个可供二次开发的程序实体。框架与架构关系 ：首先说框架不是架构，框架比架构更具体，更偏重于技术，而架构偏重于设计。还有一个关系就是架构可以通过多种框架来实现。另外，生活中说的“框架”跟软件术语中“框架”的意思不同，要注意区别。使用方法：特定领域软件有一些共性部分形成的软件架构，将这个共性的软件架构开发出来，形成一个可供二次开发的程序实体，这个程序实体就是软件框架。 可供二次开发。 设计模式（pattern）英文：A pattern is the repeated or regular way in which something happens or is done. If you refer to a way of doing something, you are referring to how you can do it, for example, the action you can take or the method you can use to achieve it.中文：设计模式强调的是一个设计问题的解决方法，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。框架与设计模式关系 ：设计模式研究的是针对单一问题的设计思路和解决方法，一个模式可应用于不同的框架和被不同的程序语言所实现；而框架则是一个应用的体系结构，是一种或多种设计模式和代码的混合体。虽然它们有所不同，但却共同致力于使人们的设计可以被重用，在思想上存在着统一性的特点，因而设计模式的思想可以在框架设计中进行应用。架构与设计模式关系 ：两者的关系也是很好区分的，设计模式主要是针对单一问题的解决方法，范畴比较小，而架构是高层次的针对体系结构的一种设计思路，范畴比较大。可以这么说，一个架构中可能会出现多个设计模式来解决多个架构中的问题。使用方法：针对特定问题提供解决方案，以供问题解决者参考。 模块（module）英文：In software, a module is a part of a program. Programs are composed of one or more independently developed modules that are not combined until the program is linked. A single module can contain one or several routines.A software module encapsulates related functions in a program together.one of a set of parts that can be connected or combined to build or complete something.中文：模块，module，模块是一个通用概念，可能从功能或其他目的来区分。模块可以是子系统子领域，主要取决于上下文环境的用法。通常我们会说程序模块，功能模块，这实际上是在按照不同的标准对模块的内容和范围的不同定义。2通常我们说的程序模块，是指的一段能够实现某个有价值目标的的成员代码段，这样的东西，我们还有另一个称呼：例程，而例程有两种，即函数和过程，它们都能实现一个有价值的目标供其它的模块使用。3而功能模块的说法一般在分析和设计阶段出现得比较频繁，通常我们用一个功能模块来说明一个功能所包含的系统行为，当我们觉得分析的颗粒度可能更大一些的时候我们可以用一个功能模块来表示一组功能的集合，这似乎让我们觉得，模块这个词的概念和“子系统”这个词的概念有些模糊，是的，事实上，有些大的模块会慢慢的让我们觉得称呼他们子系统更合适，或者一个子系统，我们会慢慢发现你还包含着一些模块。但是无论怎样，定义模块的原则应该是：高内聚和低耦合。4使用方法：就是一个描述全局中问题的概念，至于全局是什么，这个随便，比如一个人，可以看成各种功能系统，那么模块就是各种呼吸系统、消化系统等；可以看成社会关系，模块就有劳动能力、生产关系等，全在于怎么看了。 组件（component）英文：The components of something are the parts that it is made of.中文：组件，Component，首先说，组件已经不是一个抽线的概念了，是封装了一个或多个实体程序模块的实体。2组件这个词通常是现在描述产品的时候出现，一个大的产品会有很多小的部分组成，而小的部分除了是一个大的组件的部分以外，自己可能还包含更小的组件，所以组件是递归的，那么组件到底是什么呢？最常见的组件就是我们已经写好的程序代码，任何一小段代码都可以是一个组件，它可以和其它代码段连接起来组成更大的一段程序代码，一个更大的组件，然后可能是一个函数，或者一个类程序单元，或者数个类单元文件的集成，当不同的组件的组装形成更大的组件时候，我们实际就是在做我们通常提到的一件事情：集成，软件中有很多集成工作要做，每日集成，重要版本集成等等，集成是什么呢？软件中，就是链编调试。这样一来，我们知道集成是需要对被集成的组件有规模要求的，换句话说，至少是一个单元文件，所以通常说到的组件就可以直观的理解为单元文件，或者可以组成软件的其他文件，以及编译后的文件。3组件是面向对象里面的一个重[chóng]用的概念，也称为构件，组件非常类似机械中构件概念，现在机械都是走向构件生成，通过不同构件组装成一个机械成品，软件目前也是这样的一个生成方式。4维基百科上说，组件之间通过接口进行交互，这个挺起来有些象插件，现实中也是这样，比如一个dll文件，可以说是插件，也可以说是组件。插件是是组件的一个子类，就是将组件中具有某些特点的组件归为插件，这些特点是：益于与系统分离，接口明晰，可以替换的程序模块。5组件强调的是封装，利用接口进行交互。因为封装有不同层次的封装，对应不同层次的接口，（比如将一个人封装成一个组件，比如国家主席，多个人封装成一个组合，比如中央的常委们），所以组件所表述的范围和层次也是多种多样的，在谈论组件的时候一定要分辨清楚谈论的层次和范围。层次是相对的。你说地球是整个世界，但是将地球放到银河系中，地球就显得渺小了；你说物质世界是整个世界，但是人类的精神世界也是无比的浩瀚；你说物质世界和精神世界合起来是整个世界，但是历史又是那么的神秘和真实；你说物质世界、精神世界、历史时空是整个世界，但是科学家又说人类可以探察的宇宙物质仅占全部宇宙的百分之四。6使用方法：就是一个描述系统中实体单元的概念。 插件（plug-in）英文：（addin，add-in，add-on，addon，app）A plug-in is something such as a piece of software that can be added to a computer system to give extra features or functions.中文：根据对组件和模块的分析，插件属于组件，而且还是一个程序模块，也是一个功能模块。插件是一种电脑程序，通过和应用程序的互动，来替应用程式增加一些特定的功能。 插件必须依赖于应用程序才能发挥自身功能，仅靠插件是无法正常运行的。2使用方法：满足一定接口规范的具有一定功能的程序模块。开发者可以在自己软件系统中设计相应的接口以匹配某个插件，也可以设计一定的接口规范，来让别人开发插件。插件和程序之间通过接口进行交互。 控件（middleware）英文：A control is a device such as a switch or lever which you use in order to operate a machine or other piece of equipment.中文：可视化的组件。 中间件（control）英文：computer software that has an intermediary function between the various applications of a computer and its operating system.Middleware is computer software that provides services to software applications beyond those available from the operating system. It can be described as “software glue”.Middleware makes it easier for software developers to perform communication and input/output, so they can focus on the specific purpose of their application.中文：中间件是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。 原文：http://blog.csdn.net/zhangyunfei_happy/article/details/47256245]]></content>
      <categories>
        <category>架构和组件等的区别</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s简单了解]]></title>
    <url>%2F2018%2F04%2F05%2Fk8s%2F</url>
    <content type="text"><![CDATA[pring cloud项目集成docker配置首先配置pom文件，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.compo.arche.springcloud&lt;/groupId&gt; &lt;artifactId&gt;eurekaserver&lt;/artifactId&gt; &lt;version&gt;0.0.1_base&lt;/version&gt;&lt;!-- 此处版本号包含大写字母可能会有问题 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;!-- jar包 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt; &lt;version&gt;Camden.SR7&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;docker.repostory&gt;192.168.8.0&lt;/docker.repostory&gt;&lt;!-- docker 服务器位置 --&gt; &lt;docker.registry.name&gt;smartmall&lt;/docker.registry.name&gt;&lt;!-- 名称 --&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/docker&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/Dockerfile&lt;/include&gt; &lt;/includes&gt; &lt;targetPath&gt;../docker&lt;/targetPath&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;serverId&gt;harbor&lt;/serverId&gt; &lt;registryUrl&gt;192.168.8.0&lt;/registryUrl&gt; &lt;pushImage&gt;true&lt;/pushImage&gt; &lt;dockerDirectory&gt;target/docker&lt;/dockerDirectory&gt; &lt;imageName&gt; $&#123;docker.repostory&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;:$&#123;project.version&#125; &lt;/imageName&gt; &lt;imageTags&gt; &lt;imageTag&gt;$&#123;project.version&#125;&lt;/imageTag&gt; &lt;/imageTags&gt; &lt;resources&gt; &lt;rescource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/rescource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建在main下面创建一个包名：docker，然后在docker包下创建文件：Dockerfile；注意-没有扩展名内容如下：1234567891011121314151617FROM 192.168.8.0/smartmall/java:8u20MAINTAINER zzz vvv &quot;zzz@xxx.com&quot;ENV WORK_PATH /home/rootENV APP_NAME @project.build.finalName@.@project.packaging@ENV APP_VERSION @project.version@EXPOSE 9005COPY $APP_NAME $WORK_PATH/WORKDIR $WORK_PATHENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;]CMD [&quot;-jar&quot;, &quot;@project.build.finalName@.@project.packaging@&quot;] EXPOSE 9005 是设置端口号 spring cloud项目集成docker上传项目到harbor构建的时候遇到的问题12345678910111213141516[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project order-micro: Compilation failure: Compilation failure:[ERROR] /root/.jenkins/workspace/smartmallordermicro/src/main/java/com/ctsig/order/base/aspect/WebLogAspect.java:[35,51] -source 1.6 中不支持 diamond 运算符[ERROR] (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /root/.jenkins/workspace/smartmallordermicro/src/main/java/com/ctsig/order/base/config/MyBatisConfig.java:[54,56] -source 1.6 中不支持 diamond 运算符[ERROR] (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /root/.jenkins/workspace/smartmallordermicro/src/main/java/com/ctsig/order/order/controller/PostInfo.java:[98,51] -source 1.6 中不支持 diamond 运算符[ERROR] (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /root/.jenkins/workspace/smartmallordermicro/src/main/java/com/ctsig/order/base/config/DataSourceContextHolder.java:[7,80] -source 1.6 中不支持 diamond 运算符[ERROR] (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] -&gt; [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException 这个问题主要是代码格式问题，比如：12错误写法：Map&lt;Object,Object&gt; dataSourceMap = new HashMap&lt;&gt;();//此处的“&lt;&gt;”里面没有设置Object正确写法：Map&lt;Object,Object&gt; dataSourceMap = new HashMap&lt;Object, Object&gt;();]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2017%2F07%2F13%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是Java反射机制?有什么用? JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。 Java反射机制主要提供了以下功能在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。用实例 来说明 class 类的使用：获取类的属性、方法、构造方法、类的相关信息12345678910111213141516171819202122232425262728293031323334353637383940414243import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * * @author lijian *class 类的使用：获取类的属性、方法、构造方法、类的相关信息 */public class TestClass_1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //forName(String className)返回与带有给定字符串名的类或接口相关联的 Class 对象。 Class clazz = Class.forName(&quot;java.lang.String&quot;); //getDeclaredFields();返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段，包括公共、保护、默认（包）访问和私有字段，但不包括继承的字段。 Field[] field = clazz.getDeclaredFields(); System.out.println(&quot;---------------------显示类的属性----------------------------&quot;); for (Field f : field) &#123; //getName()返回此 Field 对象表示的字段的名称 //getType()返回一个 Class 对象，它标识了此 Field 对象所表示字段的声明类型。 System.out.println(f.getName() + &quot; &quot; + f.getType()); &#125; System.out.println(&quot;---------------------显示类的方法-----------------------------&quot;); //getDeclaredMethods() 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 Method[] method = clazz.getDeclaredMethods(); for (Method m : method) &#123; System.out.println(m.getName()); &#125; System.out.println(&quot;---------------------显示类的构造方法-----------------------------&quot;); //getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。 Constructor[] constructors = clazz.getDeclaredConstructors(); for(Constructor c:constructors) &#123; System.out.println(c); &#125; System.out.println(&quot;----------------------获取类的相关的信息----------------------------------------------&quot;); System.out.println(&quot;类所在的包为：&quot;+ clazz.getPackage().getName()); System.out.println(&quot;类名：&quot;+ clazz.getName()); System.out.println(&quot;父类的名称：&quot;+ clazz.getSuperclass().getName()); &#125; &#125; 以下示例中会使用到User.java类，其代码如下：12345678910public class User &#123; private String name; private int age; public User()&#123;&#125; public User(String name, int age) &#123; &#125; 属性的setter 和getter 方法 省略······ 生成一个类的Class对象有一下四种方式1234567891011121314151617181920212223242526272829import entity.User; /** * * @author lijian * 创建Class对象的4种方法 */ public class TestClass_2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; User user = new User(); // 第一种：对象.Class Class clazz = user.getClass(); // 使用包装器获取Class 对象 String str = &quot;asdasd&quot;; clazz = str.getClass(); // 第二种 ：类.class clazz = User.class; clazz = String.class; clazz = Integer.class; // 第三种：Class.forname(); clazz = Class.forName(&quot;java.lang.String&quot;); clazz = Class.forName(&quot;java.lang.Long&quot;); //第四种：包装类.type clazz = Integer.TYPE; &#125; &#125; 使用反射动态创建对象实例有两种方式： 通过Class的newInstance()方法该方法要求该Class 对象的对应类有无参构造方法,执行newInstance()实际上就是执行无参构造方法来创建该类的实例 通过Constructor的newInstance() 方法先使用Class对象获得指定的Constructor对象,再调用Constructor对象的newInstance()方法来创建该Class对象对应类的对象通过该方法可以选择使用指定的构造方法来创建对象两种方法写个简单的实例123456789101112131415161718192021222324252627282930313233343536373839404142import java.lang.reflect.Constructor; import entity.User; /** * * @author lijian * 使用反射 动态创建对象 两种方式 */ public class TestClass_3 &#123; public static void main(String[] args) throws Exception &#123; /** * 方法1：通过Class的newInstance()方法 * 该方法要求该Class对象的对应类有无参构造方法 * 执行newInstance()实际上就是执行无参构造方法来创建该类的实例 */ // Class clazz = Class.forName(&quot;entity.User&quot;); // Object obj = clazz.newInstance(); /** * 方法2：通过Constructor的newInstance()方法 * 先使用Class对象获取指定的Constructor对象 * 再调用Constructor对象的newInstance()方法来创建该Class对象对应类的对象 * 通过该方法可选择使用指定构造方法来创建对象 */ Class clazz = Class.forName(&quot;entity.User&quot;); //指定有参的构造方法 Constructor cons = clazz.getConstructor(new Class[] &#123;int.class,String.class,String.class&#125;); //使用有参数的构造方法实例对象 Object obj = cons.newInstance(new Object[]&#123;1,&quot;scott&quot;,&quot;1234&quot;&#125;); //转换为实际操作类 User user = (User)obj; //也可以调用无参构造方法，比第一种方法复杂 obj = clazz.getConstructor(new Class[]&#123;&#125;).newInstance(new Object[]&#123;&#125;); user = (User)obj; //以下也可以调用无参构造方法 obj = clazz.getConstructor().newInstance(); //转换为实际操作类 user = (User)obj; &#125; &#125; 使用反射动态修改查询的属性值通过Class对象的getFields() 或者getField()方法可以获得该类所包括的全部Field属性或指定Filed属性。Field类提供了以下方法来方法访问属性 getXxx(Object obj) ：获取obj对象该Field的属性值。此处的Xxx对应8个基本数据类型，如果该属性类型是引用类型则直接使用get(Objectobj)setXxx(Object obj,Xxx val) ：将obj对象的该Field赋值val。此处的Xxx对应8个基本数据类型，如果该属性类型是引用类型则直接使用set(Objectobj, Object val)setAccessible(Boolean flag)：若flag为true，则取消属性的访问权限控制，即使private属性也可以进行访问12345678910111213141516171819202122232425import java.lang.reflect.Field; /** * * @author lijian * 使用反射动态修改查询属性值 */ public class TestClass_4 &#123; public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName(&quot;entity.User&quot;); Object obj = clazz.newInstance();//获得类的实例 //获得 User 类中的指定属性对应的Field对象（每个属性对应一个Field对象） Field field = clazz.getDeclaredField(&quot;name&quot;); //取消属性的访问权限控制，即使private 属性也可以进行访问 field.setAccessible(true); //调用 getter 方法获取属性值 System.out.println(field.get(obj)); //调用setter 方法给属性赋值 field.set(obj, &quot;scott&quot;); //调用 getter 方法获取对应属性修改后的值 System.out.println(field.get(obj)); &#125; &#125; 使用反射动态执行方法 通过Class对象的getMethods()方法可以获得该类所包括的全部方法，返回值是Method[] 通过Class对象的getMethod() 方法可以获得该类所包括的执行方法，返回值是Method,每个Method对象对应一个方法，获得Method对象后，可以调用其invoke()来调用对应方法Objectinvoke(Object obj , Object [] args): obj代表当前方法所属的对象的名字，args代表当前方法的参数列表，返回值Object是当前方法的返回值，即执行当前方法的结果。123456789101112131415161718192021222324252627import java.lang.reflect.Method; import entity.User; /** * * @author lijian * 使用反射动态执行方法 */ public class TestClass_5 &#123; public static void main(String[] args) throws Exception&#123; Class clazz = User.class; Object obj = clazz.newInstance(); //调用该对象的 setName方法 Method method = clazz.getMethod(&quot;setName&quot;, new Class[]&#123;String.class&#125;); Object result =method.invoke(obj, new Object[]&#123;&quot;scott&quot;&#125;); // obj.setName(&quot;scott&quot;); System.out.println(&quot;返回值为：&quot;+result); //调用对象的getName()方法 Method method1 = clazz.getMethod(&quot;getName&quot;, new Class[]&#123;&#125;); Object obj1 = method1.invoke(obj, new Object[]&#123;&#125;); System.out.println(&quot;返回值为：&quot;+obj1); &#125; &#125; 使用反射动态创建数组并存取元素在java.lang.reflect包下提供了Array类，包括一系列static方法，通过这些方法可动态的创建数组、给元素赋值、取出元素值等 Array提供的主要方法如下： static ObjectnewInstance(Class&lt;?&gt; componentType, int[] dim) ：创建一个具有指定的组件类型和维度的新数组 static void setXxx(Objectarray, int index ，xxx val)：给数组对象array中第index个元素赋值val static xxx getXxx(Objectarray, int index)：以 xxx形式返回指定数组对象array中第index个元素值 1️⃣ 动态创建一维数组，并给数组赋值：123456789101112131415161718import java.lang.reflect.Array; /** * * @author lijian * 动态创建一维数组，并给数组赋值： */ public class TestClass_6 &#123; public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName(&quot;java.lang.Integer&quot;); Object array = Array.newInstance(clazz, 10);//根据类的class 创建大小为10的数组 Array.set(array, 5, 10);//给数组的第5个元素赋值为10 Object el = Array.get(array, 5);//取出数组的第5个元素值显示 System.out.println(el); &#125; &#125; 2️⃣ 动态创建二维数组，并给数组赋值：123456789101112131415161718import java.lang.reflect.Array; /** * * @author lijian *动态创建二维数组，并给数组赋值： */ public class TestClass_7 &#123; public static void main(String[] args) &#123; int dims[] = &#123;10,15&#125;; Object array = Array.newInstance(int.class, dims);//创建一个10行15列二维数组，等价与：array[10][15] Object array1 = Array.get(array, 5);//获取二维数组中的第5行 Array.set(array1, 8, 300); //给数组的第5行8列赋值300，等价与：array[5][8]=300 Object el = Array.get(array1, 8);//取出数组中第5行8列的值 System.out.println(el); &#125; &#125; Standard annotation type(Built-in annotation):@Override(when extends parent),@SuppressWarnings(wipe off the warnings) Meta annotation type(decorate other annotation definition):@Target,@Retention user-defined(define by oneself,it is an interface):use the key @interface to define for example:123456789101112131415161718192021222324252627282930313233343536373839404142//define the annotation DBFieldpackage annotationimport java.lang.Retention;import java.lang.Target;import java.lang.RetentionPolicy;import java.lang.ElementType;@Target(Element.Field)@Retention(RetentionPolicy.Runtime)public @interface DBField &#123;public String getDBField() default &quot;SQL&quot;; &#125;//DAO use the annotationpackage annotation;public class UserInfoDAO &#123;@DBFiledObject obj; &#125;//the result is SQLimport annotation.DBField;public class TestAnnotation&#123; public static void main(String args[])&#123; Class&lt;?&gt; alz = Class.forName(&quot;annotation.UserInfoDAO&quot;); Field fields[] = clz.getDeclaredFields(); for(Field f : fields)&#123; Systom.out.println(f.getName()); Annotation[] annField=f.getAnnotations(); if(annField[0] instanceof DBField)&#123; System.out.println(((DBField)annField[0]).getDBField()) &#125; &#125; &#125;&#125; JAVA-反射-getGenericSuperclass（）介绍1234567891011121314151617181920212223242526272829 public class Person&lt;T&gt; &#123; &#125; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; public class Student extends Person&lt;Student&gt; &#123; public static void main(String[] args) &#123; Student st=new Student(); Class clazz=st.getClass(); //getSuperclass()获得该类的父类 System.out.println(clazz.getSuperclass()); //getGenericSuperclass()获得带有泛型的父类 //Type是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。 Type type=clazz.getGenericSuperclass(); System.out.println(type); //ParameterizedType参数化类型，即泛型 ParameterizedType p=(ParameterizedType)type; //getActualTypeArguments获取参数化类型的数组，泛型可能有多个 Class c=(Class) p.getActualTypeArguments()[0]; System.out.println(c); &#125; &#125;打印结果： class com.test.Person29 com.test.Person&lt;com.test.Student&gt;class com.test.Student]]></content>
      <categories>
        <category>反射</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2017%2F06%2F16%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[单利模式Singleton 模式主要作用是保证在 Java 应用程序中，一个类 Class 只有一个实例存在。 一般 Singleton 模式通常有几种种形式 第一种形式定义一个类，它的 构造函数为 private 的，它 有一个 static 的 private 的该类变量，在 类初始化时实例话，通过一个 public 的 getInstance 方法获取对它的 引用,继而调用其中的方法。1234567891011public class Singleton &#123;private Singleton()&#123;&#125;//在自己内部定义自己一个实例，是不是很奇怪？ //注意这是 private 只供内部调用private static Singleton instance = new Singleton();//这里提供了一个供外部访问本 class 的静态方法，可以直接访问 public static Singleton getInstance() &#123;return instance;&#125;&#125; 第二种形式123456789public class Singleton &#123;private static Singleton instance = null;public static synchronized Singleton getInstance() &#123; //这个方法比上面有所改进，不用每次都进行生成对象，只是第一次 //使用时生成实例，提高了效率！if (instance==null)&#123;instance＝new Singleton(); &#125;return instance; &#125;&#125; 其他形式定义一个类，它的构造函数为 private 的，所有方法为 static 的。一般认为第一种形式要更加安全些 spring 单例模式和非单例模式测试 12345678910111213141516171819202122232425262728293031&lt;bean id=&quot;singleton&quot; class=&quot;java.util.Date&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;prototype&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;package test;import java.util.Date;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.opensymphony.xwork2.ActionContext;public class TestScope &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext-web.xml&quot;); Date s1=(Date)context.getBean(&quot;singleton&quot;); Date p1=(Date)context.getBean(&quot;prototype&quot;); Date s2=(Date)context.getBean(&quot;singleton&quot;); Date p2=(Date)context.getBean(&quot;prototype&quot;); System.out.println(&quot;单例：&quot;+(s1==s2)); System.out.println(&quot;非单例：&quot;+(p1==p2)); &#125;&#125; 结果12单例：true非单例：false 装饰器模式和代理模式装饰器模式和代理模式之间还是有很多差别的。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。 代理模式12345678910111213141516171819202122public class Proxy implements Subject&#123; private Subject subject; public Proxy()&#123; //关系在编译时确定 subject = new RealSubject(); &#125; public void doAction()&#123; …. subject.doAction(); …. &#125;&#125;//代理的客户public class Client&#123; public static void main(String[] args)&#123; //客户不知道代理委托了另一个对象 Subject subject = new Proxy(); … &#125;&#125; 装饰器模式1234567891011121314151617181920public class Decorator implements Component&#123; private Component component; public Decorator(Component component)&#123; this.component = component &#125; public void operation()&#123; … component.operation(); … &#125;&#125;//装饰器的客户public class Client&#123; public static void main(String[] args)&#123; //客户指定了装饰者需要装饰的是哪一个类 Component component = new Decorator(new ConcreteComponent()); … &#125;&#125; 推荐阅读👉23种设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[restFul简介]]></title>
    <url>%2F2017%2F05%2F12%2FrestFul%2F</url>
    <content type="text"><![CDATA[RESTful1.使用标准的HTTP方法（create，delete）2.无状态性：RESTful只要维护资源的状态，而不需要维护客户端的状态。对于它来说，每次请求都是全新的，它只需要针对本次请求作相应的操作，不需要将本次请求的相关信息记录下来以便用于后续来自相同客户端请求的处理。3.多资源表示方式由于REST是面向资源的，所以一个Web API旨在实现针对单一资源的操作。我们在前面已经说个，针对资源的基本操作唯CRUD而已，这是使我们可以为Web API定义标准接口成可能。所谓的标准接口就是针对不同资源的Web API定义一致性的操作来操作它们，其接口可以采用类似于下面的模式。 public class ResourceService { public IEnumerable&lt;Resource&gt;[] Get(); public void Create(Resource resource); public void Update(Resource resource); public void Delete(string id); } 比如我们分别发送PUT和POST请求以添加一个员工，标识员工的URI由其员工ID来决定。如果员工ID由客户端来指定，我们可以发送PUT请求；如果员工ID由服务端生成，我们一般发送POST请求。具体的请求与下面提供的代码片断类似，可以看出它们的URI也是不一样的。 PUT http://www.artech.com/employees/300357 HTTP/1.1 ... &lt;employee&gt; &lt;id&gt;300357&lt;/id&gt; &lt;name&gt;张三&lt;/name&gt; &lt;gender&gt;男&lt;gender&gt; &lt;birthdate&gt;1981-08-24&lt;/birthdate&gt; &lt;department&gt;3041&lt;/department&gt; &lt;/employee&gt; POST http://www.artech.com/employees HTTP/1.1 ... &lt;employee&gt; &lt;name&gt;张三&lt;/name&gt; &lt;gender&gt;男&lt;gender&gt; &lt;birthdate&gt;1981-08-24&lt;/birthdate&gt; &lt;department&gt;3041&lt;/department&gt; &lt;/employee&gt; POST和PUT请求一般将所加资源的内容置于请求的主体。但是对于PUT请求来说，如果添加资源的内容完全可以由其URI来提供，这样的请求可以不需要主体。比如我们通过请求添加一个用于控制权限的角色，标识添加角色的URI由其角色名称来决定，并且不需要指定除角色名称的其它信息，那么我们只要发送如下一个不含主体的PUT请求即可。 PUT http://www.artech.com/roles/admin HTTP/1.1 ... 除了进行资源的添加，PUT请求还能用于资源的修改。由于请求包含提交资源的标识（可以放在URI中，也可以置于保存在主体部分的资源内容中），所以服务端能够定位到对应的资源予以修改。对于POST和PUT，也存在一种一刀切的说法：POST用于添加，PUT用于修改。我个人比较认可的是：如果PUT提供的资源不存在，则做添加操作，否则做修改。 webservice：Webservice是使应用程序以与平台和编程语言无关的方式进行相互通信技术。XML（标准通用标记语言下的一个子集）：XML是在web上传送结构化数据的伟大方式，Web services要以一种可靠的自动的方式操作数据，HTML（标准通用标记语言下的一个应用）不会满足要求，而XML可以使web services十分方便的处理数据，它的内容与表示的分离十分理想；SOAP：SOAP使用XML消息调用远程方法，这样web services可以通过HTTP协议的post和get方法与远程机器交互，而且，SOAP更加健壮和灵活易用；其他像UDDI和WSDL技术与XML和SOAP技术紧密结合用于服务发现。从表面上看，Web service 就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法通过Web来调用这个应用程序。我们把调用这个Web service 的应用程序叫做客户。例如，你想创建一个Web service ，它的作用是返回当前的天气情况。那么你可以建立一个ASP页面，它接受邮政编码作为查询字符串，然后返回一个由逗号隔开的字符串，包含了当前的气温和天气。要调用这个ASP页面，客户端需要发送下面的这个HTTP GET返回的数据就应该是这样：这个ASP页面就应该可以算作是Web service 了。因为它基于HTTP GET请求，暴露出了一个可以通过Web调用的API。当然，Web service 还有更多的东西。下面是对Web service 更精确的解释： Web services是建立可互操作的分布式应用程序的新平台。作为一个Windows程序员，你可能已经用COM或DCOM建立过基于组件的分布式应用程序。COM是一个非常好的组件技术，但是我们也很容易举出COM并不能满足要求的情况。Web service平台是一套标准，它定义了应用程序如何在Web上实现互操作性。你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。 技术支持Web Service平台需要一套协议来实现分布式应用程序的创建。任何平台都有它的数据表示方法和类型系统。要实现互操作性，Web Service平台必须提供一套标准的类型系统，用于沟通不同平台、编程语言和组件模型中的不同类型系统。这些协议有： XML和XSD可扩展的标记语言（标准通用标记语言下的一个子集）是Web Service平台中表示数据的基本格式。除了易于建立和易于分析外，XML主要的优点在于它既与平台无关，又与厂商无关。XML是由万维网协会(W3C)创建，W3C制定的XML SchemaXSD 定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。Web Service平台是用XSD来作为数据类型系统的。当你用某种语言如VB. NET或C# 来构造一个Web Service时，为了符合Web Service标准，所有你使用的数据类型都必须被转换为XSD类型。如想让它使用在不同平台和不同软件的不同组织间传递，还需要用某种东西将它包装起来。这种东西就是一种协议，如 SOAP。 xml web serviceSOAPSOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML（标准通用标记语言下的一个子集）编码信息的轻量级协议。它有三个主要方面：XML-envelope为描述信息内容和如何处理内容定义了框架，将程序对象编码成为XML对象的规则，执行远程过程调用(RPC)的约定。SOAP可以运行在任何其他传输协议上。例如，你可以使用 SMTP，即因特网电子邮件协议来传递SOAP消息，这可是很有诱惑力的。在传输层之间的头是不同的，但XML有效负载保持相同。Web Service 希望实现不同的系统之间能够用“软件-软件对话”的方式相互调用，打破了软件应用、网站和各种设备之间的格格不入的状态，实现“基于Web无缝集成”的目标。 WSDLWeb Service描述语言WSDL 就是用机器能阅读的方式提供的一个正式描述文档而基于XML（标准通用标记语言下的一个子集）的语言，用于描述Web Service及其函数、参数和返回值。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的。UDDI（Universal Description，Discovery，and Integration）：统一描述、发现和集成，用于集中存放和查找WSDL描述文件，起着目录服务器的作用。UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。 调用RPC与消息传递Web Service本身其实是在实现应用程序间的通信。我们有两种应用程序通信的方法：RPC远程过程调用 和消息传递。使用RPC的时候，客户端的概念是调用服务器上的远程过程，通常方式为实例化一个远程对象并调用其方法和属性。RPC系统试图达到一种位置上的透明性：服务器暴露出远程对象的接口，而客户端就好像在本地使用的这些对象的接口一样，这样就隐藏了底层的信息，客户端也就根本不需要知道对象是在哪台机器上。]]></content>
      <categories>
        <category>restFul</category>
      </categories>
      <tags>
        <tag>restFul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webservice]]></title>
    <url>%2F2017%2F04%2F01%2Fwebservice%2F</url>
    <content type="text"><![CDATA[可能会用到的调用web service的客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* JaxWsProxyFactoryBean proxyFactoryBean=new JaxWsProxyFactoryBean(); //设置访问地址 proxyFactoryBean.setAddress(&quot;http://127.0.0.1:8089/user?wsdl&quot;); //设置portType proxyFactoryBean.setServiceClass(IUsersService.class); //获取服务对象 IUsersService usersService= (IUsersService) proxyFactoryBean.create(); usersService.getAge(&quot;李白&quot;); Client client = new Client(new URL(&quot;http://127.0.0.1:8089/user?wsdl&quot;)); Object[] results = client.invoke(&quot;getAge&quot;, new Object[] &#123; &quot;李白&quot; &#125;); System.out.println(results[0]);*/ &#125; /*try &#123; String endpoint = &quot;http://localhost:8088/weather&quot;; //直接引用远程的wsdl文件 Service service = new Service(); Call call = (Call) service.createCall(); call.setTargetEndpointAddress(endpoint); //call.setOperationName(&quot;getName&quot;);//wsdl里面描述的接口名称 call.addParameter(&quot;userId&quot;, XMLType.XSD_DATE, ParameterMode.IN);//接口的参数 call.setReturnType(XMLType.XSD_STRING);//设置返回类型 call.invoke(&quot;getName&quot;,new Object[]&#123;10001&#125;);//给方法传递参数，并且调用方法 // System.out.println(&quot;result is &quot; + result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;*/&#125; /* JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance(); Client client = dcf.createClient(&quot;http://192.168.122.71:8000/services/resourceService?wsdl&quot;); Object[] objects = new Object[0]; String param=&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\n&quot; + &quot;&lt;soap:Envelope xmlns:soap=\&quot;http://schemas.xmlsoap.org/soap/envelope/\&quot; xmlns:soapenc=\&quot;http://schemas.xmlsoap.org/soap/encoding/\&quot; xmlns:tns=\&quot;http://serv.services.rs.idc.regaltec.com\&quot; xmlns:types=\&quot;http://serv.services.rs.idc.regaltec.com/encodedTypes\&quot; xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot; xmlns:xsd=\&quot;http://www.w3.org/2001/XMLSchema\&quot;&gt;\n&quot; + &quot; &lt;soap:Body soap:encodingStyle=\&quot;http://schemas.xmlsoap.org/soap/encoding/\&quot;&gt;\n&quot; + &quot; &lt;tns:queryRoom&gt;\n&quot; + &quot; &lt;inputXml xsi:type=\&quot;xsd:string\&quot;&gt;&amp;lt;idcCenterCode&amp;gt;Mega_IDC_4&amp;lt;/idcCenterCode&amp;gt;&lt;/inputXml&gt;\n&quot; + &quot; &lt;/tns:queryRoom&gt;\n&quot; + &quot; &lt;/soap:Body&gt;\n&quot; + &quot;&lt;/soap:Envelope&gt;&quot;; try &#123; objects = client.invoke(&quot;queryRoom&quot;, param); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;//输出调用结果 System.out.println(objects[0].getClass()); System.out.println(objects[0].toString()); &#125;*/]]></content>
      <categories>
        <category>webservice</category>
      </categories>
      <tags>
        <tag>webservice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven简介]]></title>
    <url>%2F2016%2F12%2F24%2Fmaven%2F</url>
    <content type="text"><![CDATA[maven pom文件配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;docbuilder&lt;/artifactId&gt; &lt;groupId&gt;com.jiepu&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;Core&lt;/artifactId&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;sax&lt;/groupId&gt; &lt;artifactId&gt;sax&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 本地lib引用，不用的就删除掉,demo而已--&gt; &lt;dependency&gt; &lt;groupId&gt;org.sqlite&lt;/groupId&gt; &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt; &lt;version&gt;3.7.2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/sqlite-jdbc-3.7.2.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;!-- 强制设置JDK编译版本为1.8 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0 &quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance &quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd &quot;&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符--&gt; &lt;artifactId/&gt; &lt;!--被继承的父项目的全球唯一标识符--&gt; &lt;groupId/&gt; &lt;!--被继承的父项目的版本--&gt; &lt;version/&gt; &lt;!--父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt; &lt;!--构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。--&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目的名称, Maven产生的文档用--&gt; &lt;name&gt;banseon-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;!--项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。--&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt; &lt;maven/&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字，--&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL--&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息--&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum--&gt; &lt;system/&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt; &lt;url/&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt; &lt;notifier&gt; &lt;!--传送通知的途径--&gt; &lt;type/&gt; &lt;!--发生错误时是否通知--&gt; &lt;sendOnError/&gt; &lt;!--构建失败时是否通知--&gt; &lt;sendOnFailure/&gt; &lt;!--构建成功时是否通知--&gt; &lt;sendOnSuccess/&gt; &lt;!--发生警告时是否通知--&gt; &lt;sendOnWarning/&gt; &lt;!--不赞成使用。通知发送到哪里--&gt; &lt;address/&gt; &lt;!--扩展配置项--&gt; &lt;configuration/&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt; &lt;inceptionYear/&gt; &lt;!--项目相关邮件列表信息--&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt; &lt;mailingList&gt; &lt;!--邮件的名称--&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL--&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表--&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息--&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符--&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名--&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email--&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL--&gt; &lt;url/&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织--&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL--&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等--&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表--&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素--&gt; &lt;contributor&gt; &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt; &lt;license&gt; &lt;!--license用于法律上的名称--&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL--&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息--&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt; &lt;tag/&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt; &lt;organization&gt; &lt;!--组织的全名--&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL--&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;sourceDirectory/&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt; &lt;scriptSourceDirectory/&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;testSourceDirectory/&gt; &lt;!--被编译过的应用程序class文件存放的目录。--&gt; &lt;outputDirectory/&gt; &lt;!--被编译过的测试class文件存放的目录。--&gt; &lt;testOutputDirectory/&gt; &lt;!--使用来自该项目的一系列构建扩展--&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。--&gt; &lt;extension&gt; &lt;!--构建扩展的groupId--&gt; &lt;groupId/&gt; &lt;!--构建扩展的artifactId--&gt; &lt;artifactId/&gt; &lt;!--构建扩展的版本--&gt; &lt;version/&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt; &lt;defaultGoal/&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt; &lt;resource&gt; &lt;!--描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt; &lt;targetPath/&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt; &lt;filtering/&gt; &lt;!--描述存放资源的目录，该路径相对POM路径--&gt; &lt;directory/&gt; &lt;!--包含的模式列表，例如**/*.xml.--&gt; &lt;includes/&gt; &lt;!--排除的模式列表，例如**/*.xml--&gt; &lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录--&gt; &lt;directory/&gt; &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt; &lt;finalName/&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt; &lt;filters/&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt; &lt;extensions/&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息--&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id/&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase/&gt; &lt;!--配置的执行目标--&gt; &lt;goals/&gt; &lt;!--配置是否被传播到子POM--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表--&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt; &lt;id/&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志--&gt; &lt;activeByDefault/&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt; &lt;jdk/&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字--&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;)--&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本--&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt; &lt;property&gt; &lt;!--激活profile的属性的名称--&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值--&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。--&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。--&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素--&gt; &lt;build&gt; &lt;defaultGoal/&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素--&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports/&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt; &lt;reporting&gt; &lt;/reporting&gt; &lt;!--参见dependencyManagement元素--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素--&gt; &lt;distributionManagement&gt; &lt;/distributionManagement&gt; &lt;!--参见properties元素--&gt; &lt;properties/&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息--&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载--&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled/&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt; &lt;updatePolicy/&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt; &lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称--&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID--&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID--&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!--依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。--&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!--依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。--&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt; &lt;excludeDefaults/&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt; &lt;outputDirectory/&gt; &lt;!--使用的报表插件和他们的配置。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息--&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--报表插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的报表插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--报表插件的配置--&gt; &lt;configuration/&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到--&gt; &lt;id/&gt; &lt;!--产生报表集合时，被使用的报表的配置--&gt; &lt;configuration/&gt; &lt;!--配置是否被继承到子POMs--&gt; &lt;inherited/&gt; &lt;!--这个集合里使用到哪些报表--&gt; &lt;reports/&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!--继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt; &lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt; &lt;layout/&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout/&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息--&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称--&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt; &lt;downloadUrl/&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt; &lt;relocation&gt; &lt;!--构件新的group ID--&gt; &lt;groupId/&gt; &lt;!--构件新的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--构件新的版本号--&gt; &lt;version/&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt; &lt;message/&gt; &lt;/relocation&gt; &lt;!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。--&gt; &lt;status/&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt; &lt;properties/&gt; &lt;/project&gt;]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2016%2F12%2F13%2Fsorting-algorithm%2F</url>
    <content type="text"><![CDATA[冒泡 1234567891011121314void BubbleSortArray() &#123; int i,j,temp; for(i=1;i&lt;n;i++) &#123; for(j=0;j&lt;n-i;j++) &#123; if(a[j]&gt;a[j+1]) //比较交换相邻元素 &#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; &#125; 快速排序快速排序（Quicksort）是对冒泡排序的一种改进，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。时间复杂度为O(nlog2n)，适用于排序大列表。 123456789101112131415161718192021222324252627282930313233void swap(int a,int b)&#123;int t;t =a ;a =b ;b =t ;&#125; int Partition(int [] arr,int low,int high) &#123; int pivot=arr[low]; //采用子序列的第一个元素作为枢纽元素 while (low &lt; high) &#123; //从后往前在后半部分中寻找第一个小于枢纽元素的元素 while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123; --high; &#125; swap(arr[low], arr[high]);//将这个比枢纽元素小的元素交换到前半部分 //从前往后在前半部分中寻找第一个大于枢纽元素的元素 while (low &lt;high &amp;&amp;arr [low ]&lt;=pivot ) &#123; ++low ; &#125; swap (arr [low ],arr [high ]);//将这个枢纽元素大的元素交换到后半部分 &#125; return low ; //返回枢纽元素所在的位置 &#125; void QuickSort(int [] a,int low,int high) &#123; if (low &lt;high ) &#123; int n=Partition (a ,low ,high ); QuickSort (a ,low ,n ); QuickSort (a ,n +1,high ); &#125; &#125; ArrayList和Vector的区别,HashMap和Hashtable的区别以及线程安全的理解就ArrayList与Vector主要从二方面来说. 同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的 数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 就HashMap与HashTable主要从三方面来说。 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 值：只有HashMap可以让你将空值作为一个表的条目的key或value 什么是线程安全？如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。举例比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成： 在 Items[Size] 的位置存放此元素； 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 java中的native关键字native修饰的拾非java语言代码接口，一般有实现体，不修饰abstract]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2016%2F12%2F10%2Fmysql%2F</url>
    <content type="text"><![CDATA[mysql的总结的练习题命令行登陆MySQL在windows系统‘运行’一栏中输入mysql -uroot -p123456 test 就可以直接进入登陆到MySQL服务器test数据库 执行MySQL dump数据文件，进入windows cmd命令界面mysql -uroot -p123456 test &lt;D:\test_db-master\load_employees.dump 翻倍执行插入数据，即快速插入测试数据,注意，id可以设置自增，这样不用插入INSERT into tablename(rate,create_time) SELECT rate, create_time FROM tablename 修改root用户密码1234mysql -u root;mysql&gt; use mysql;mysql&gt; UPDATE user SET Password = PASSWORD(&apos;newpass&apos;) WHERE user = &apos;root&apos;;mysql&gt; FLUSH PRIVILEGES; 登陆root用户，给用户赋予创建数据库的权限 ；用户：XXX，密码：XXX创建用户：12CREATE USER &apos;tester&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;wangan&apos;;grant all privileges on *.* to tester@localhost identified by &apos;password&apos;; 之后登陆tester用户 mysql -u tester -p创建数据库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CREATE DATABASE idc DEFAULT CHARACTER SET utf8 ;studentINSERT INTO student(id,NAME,chinese,english,math) VALUES(1,&apos;张小明&apos;,89,78,90);INSERT INTO student(id,NAME,chinese,english,math) VALUES(2,&apos;李进&apos;,67,53,95);INSERT INTO student(id,NAME,chinese,english,math) VALUES(3,&apos;王五&apos;,87,78,77);INSERT INTO student(id,NAME,chinese,english,math) VALUES(4,&apos;李一&apos;,88,98,92);INSERT INTO student(id,NAME,chinese,english,math) VALUES(5,&apos;李来财&apos;,82,84,67);INSERT INTO student(id,NAME,chinese,english,math) VALUES(6,&apos;张进宝&apos;,55,85,45);INSERT INTO student(id,NAME,chinese,english,math) VALUES(7,&apos;黄蓉&apos;,75,65,30);SHOW DATABASESCREATE DATABASE shop DEFAULT CHARACTER SET utf8 SHOW DATABASES SHOW CREATE DATABASE shopDROP DATABASE shopstudent1CREATE TABLE student1( sid INT, sname VARCHAR(20), sage INT )DESC studentDROP TABLE student1SHOW TABLESALTER TABLE student ADD COLUMN sgender VARCHAR(2)ALTER TABLE student MODIFY COLUMN NAME VARCHAR(40)ALTER TABLE student DROP COLUMN sgenderALTER TABLE student CHANGE COLUMN sgender gender VARCHAR(2)ALTER TABLE teacher RENAME TO studentDESC teacher ALTER TABLE student ADD COLUMN java就业班 VARCHAR(10)SELECT * FROM student SELECT id ,NAME,(english+math) AS &apos;成绩&apos; FROM studentSELECT DISTINCT gender FROM studentSELECT * FROM student WHERE gender &lt;&gt; &apos;男&apos;SELECT COUNT(id) FROM student -- 总记录SELECT * FROM student LIMIT 1,2 -- 从第2 条记录开始查询,查2条SELECT * FROM student ORDER BY id DESC LIMIT 2,5 -- 排序SELECT gender, COUNT(gender) FROM student GROUP BY genderSELECT gender,COUNT(gender) gen FROM student GROUP BY gender HAVING gen&gt;2 ALTER TABLE student ADD hi VARCHAR(10)ALTER TABLE student DROP hiCREATE TABLE student1( id INT ZEROFILL PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20))SELECT * FROM student1INSERT INTO student1(NAME) VALUES (&apos;张三&apos;)DELETE FROM student1TRUNCATE TABLE student1CREATE TABLE dept( id INT PRIMARY KEY, deptName VARCHAR(20))CREATE TABLE emp( id INT PRIMARY KEY, empName VARCHAR(20), dept_id INT, CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES dept(id)) 存储过程不带参数123456789DROP PROCEDURE IF EXISTS pro_test;DELIMITER $ -- 声明存储过程的结束符 CREATE PROCEDURE pro_test() BEGIN SELECT * FROM student ; SELECT COUNT(1) FROM student; END$CALL pro_test() -- 执行存储过程 带输入参数的12345678DROP PROCEDURE IF EXISTS pro_findById;DELIMITER $CREATE PROCEDURE pro_findById(IN aid INT) BEGIN SELECT * FROM student WHERE id=aid;END $CALL pro_findById(2) 带输出参数1234567891011121314151617DROP PROCEDURE IF EXISTS pro_out; DELIMITER $ CREATE PROCEDURE pro_out(OUT str VARCHAR(20)) BEGIN SET str=&apos;hell1234&apos;; END $DROP PROCEDURE IF EXISTS pro_testOut;DELIMITER $CREATE PROCEDURE pro_testOut(OUT str VARCHAR(20)) -- OUT：输出参数BEGIN -- 给参数赋值 SET str=&apos;helljava&apos;;END $CALL pro_testOut(@NAME) -- 定义会话变量,接受存储过程的值SELECT @NAME -- 接收输出参数的值 带有输入输出参数123456789101112131415161718192021222324252627282930313233DELIMITER $CREATE PROCEDURE pro_inout(INOUT n INT)BEGIN SELECT n;SET n=500;END $-- 调用CALL pro_inout(@n)-- 查询SELECT @n-- 调用SET @n=10-- 带条件判断的存储过程DELIMITER $CREATE PROCEDURE pro_testif(IN num INT, OUT str VARCHAR(20))BEGIN IF num=1 THEN SET str=&apos;星期一&apos;; ELSEIF num=2 THEN SET str=&apos;星期二&apos;; ELSEIF num=3 THEN SET str=&apos;星期三&apos;; ELSE SET str=&apos;输入有误&apos;; END IF;END $CALL pro_testif(1,@str)SELECT @str 带有循环功能的123456789101112131415DROP PROCEDURE IF EXISTS pro_testwhile;DELIMITER $CREATE PROCEDURE pro_testwhile(IN num INT, OUT result INT)BEGIN DECLARE i INT DEFAULT 1; DECLARE vsum INT DEFAULT 0; WHILE i&lt;=num DO SET vsum=i+vsum; SET i=i+1; END WHILE; SET result=vsum ;END $CALL pro_testwhile(10,@result)SELECT @result 使用查询的结果赋值给变量 into12345678DELIMITER $CREATE PROCEDURE pro_testinto(IN eid INT,OUT vname VARCHAR(20))BEGIN SELECT empname INTO vname FROM emp WHERE id=eid;END $ CALL pro_testinto(1,@vname)SELECT @vname 触发器当操作了某张表时，希望同时触发一些动作/行为，可以使用触发器完成！！例如： 当向员工表插入一条记录时，希望同时往日志表插入数据员工日志表123456789CREATE TABLE emp_log( content VARCHAR(100))CREATE TRIGGER tri_empAdd AFTER INSERT ON emp FOR EACH ROW -- 删除和修改一样,将INSERT改成UPDATE 和 deleteINSERT INTO emp_log(content) VALUES (&apos;员工表插入了一条记录&apos;) INSERT INTO emp(empName,dept_id) VALUES (&apos;刘备&apos;,1) 权限问题12USE mysqlSELECT * FROM USER 修改密码UPDATE USER SET PASSWORD(&#39;123456&#39;) WHERE USER=&#39;root&#39;分配权限账户12GRANT SELECT ON test.emp_log TO rootUPDATE emp_log SET content=&apos;hihoa&apos; 创建mysql&gt; create user zx_root IDENTIFIED by &#39;xxxxx&#39;; //identified by 会将纯文本密码加密作为散列值存储修改mysql&gt;rename user feng to newuser；//mysql 5之后可以使用，之前需要使用update 更新user表删除mysql&gt;drop user newuser; //mysql5之前删除用户时必须先使用revoke 删除用户权限，然后删除用户，mysql5之后drop命令可以删除用户的同时删除用户的相关权限更改密码12mysql&gt; set password for zx_root =password(&apos;xxxxxx&apos;);mysql&gt; update mysql.user set password=password(&apos;xxxx&apos;) where user=&apos;otheruser&apos; 查看用户权限mysql&gt; show grants for zx_root;赋予权限mysql&gt; grant select on dmc_db.* to zx_root;回收权限mysql&gt; revoke select on dmc_db.* from zx_root; //如果权限不存在会报错 上面的命令也可使用多个权限同时赋予和回收，权限之间使用逗号分隔mysql&gt; grant select，update，delete ，insert on dmc_db.* to zx_root;如果想立即看到结果使用flush privileges ;命令更新设置权限时必须给出一下信息 要授予的权限 授予访问权限的数据库或表 用户名 grant和revoke可以在几个层次上控制访问权限 整个服务器，使用 grant ALL 和revoke ALL 整个数据库，使用on database.* 特点表，使用on database.table 特定的列 特定的存储过程 user表中host列的值的意义% 匹配所有主机localhost localhost不会被解析成IP地址，直接通过UNIXsocket连接127.0.0.1 会通过TCP/IP协议连接，并且只能在本机访问；::1 ::1就是兼容支持ipv6的，表示同ipv4的127.0.0.11234567grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利grant select, insert, update, delete on test.* to root@&apos;%&apos;grant 数据库开发人员，创建表、索引、视图、存储过程、函数。。。等权限。grant 创建、修改、删除 MySQL 数据表结构权限。grant create on test.* to developer@’192.168.0.%’;grant alter on test.* to developer@’192.168.0.%’;grant drop on test.* to developer@’192.168.0.%’;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令大全]]></title>
    <url>%2F2016%2F12%2F03%2Flinux%2F</url>
    <content type="text"><![CDATA[进入带空格的文件或者文件夹1234567891011121314151617root@ubuntu:/home/wangan/桌面/wang an# cd /rootroot@ubuntu:~# lsMyEclipse Professional 2014root@ubuntu:~# cd MyEclipse\ Professional\ 2014root@ubuntu:~/MyEclipse Professional 2014# lsartifacts.xml dropins icon.xpm myeclipse.ini pluginsbinary epl-v10.html libcairo-swt.so notice.html readmeconfiguration features myeclipse p2 Uninstallerroot@ubuntu:~/MyEclipse Professional 2014# ls -l总用量 1068-rw-r--r-- 1 root root 413582 Nov 19 19:20 artifacts.xmldrwxr-xr-x 3 root root 4096 Nov 19 19:20 binarydrwxr-xr-x 13 root root 4096 Nov 19 19:34 configurationdrwxr-xr-x 2 root root 4096 Nov 19 19:20 dropins-rw-r--r-- 1 root root 16536 Jun 30 2013 epl-v10.htmldrwxr-xr-x 204 root root 20480 Nov 19 19:20 features-rw-r--r-- 1 root root 55371 Nov 15 2013 icon.xpm Linux文件权限详解 文件和目录权限概述在linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。 通过设定权限可以从以下三种访问方式限制访问权限：只允许用户自己访问；允许一个预先指定的用户组中的用户访问；允许系统中的任何用户访问。同时，用户能够控制一个给定的文件或目录的访问程度。一个文件活目录可能有读、写及执行权限。当创建一个文件时，系统会自动地赋予文件所有者读和写的权限，这样可以允许所有者能够显示文件内容和修改文件。文件所有者可以将这些权限改变为任何他想指定的权限。一个文件也许只有读权限，禁止任何修改。文件也可能只有执行权限，允许它想一个程序一样执行。 三种不同的用户类型能够访问一个目录或者文件：所有着、用户组或其他用户。所有者就是创建文件的用户，用户是所有用户所创建的文件的所有者，用户可以允许所在的用户组能访问用户的文件。通常，用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。最后，用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是other用户类。每一个用户都有它自身的读、写和执行权限。第一套权限控制访问自己的文件权限，即所有者权限。第二套权限控制用户组访问其中一个用户的文件的权限。第三套权限控制其他所有用户访问一个用户的文件的权限，这三套权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。 我们可以用-l参数的ls命令显示文件的详细信息，其中包括权限。如下所示：1234567$ ls -lh总用量 191M-rwxrwx--- 1 root plugdev 18M 2007-02-28 18:05 ActionCube_v0.92.tar.bz2-rwxrwx--- 1 root plugdev 60M 2007-04-30 22:52 nexuiz-223.zip-rwxrwx--- 1 root plugdev 7.4M 2007-04-25 02:16 stardict-oxford-gb-2.4.2.tar.bz2-rwxrwx--- 1 root plugdev 102M 2007-05-01 18:22 tremulous-1.1.0-installer.x86.run-rwxrwx--- 1 root plugdev 4.9M 2007-04-30 14:32 wqy-bitmapfont-0.8.1-7_all.deb.bin 当执行ls -l 或 ls -al 命令后显示的结果中，最前面的第2～10个字符是用来表示权限。第一个字符一般用来区分文件和目录： d：表示是一个目录，事实上在ext2fs中，目录是一个特殊的文件。 -：表示这是一个普通的文件。 l: 表示这是一个符号链接文件，实际上它指向另一个文件。 b、c：分别表示区块设备和其他的外围设备，是特殊类型的文件。 s、p：这些文件关系到系统的数据结构和管道，通常很少见到。 权限的种类和设置权限的方法。一般权限第2～10个字符当中的每3个为一组，左边三个字符表示所有者权限，中间3个字符表示与所有者同一组的用户的权限，右边3个字符是其他用户的权限。这三个一组共9个字符，代表的意义如下： r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权 w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。 x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。 表示不具有该项的权限。 -rwx——: 文件所有者对文件具有读取、写入和执行的权限。 -rwxr―r–: 文件所有者具有读、写与执行的权限，其他用户则具有读取的权限。 -rw-rw-r-x: 文件所有者与同组用户对文件具有读写的权限，而其他用户仅具有读取和执行的权限。 drwx–x–x: 目录所有者具有读写与进入目录的权限,其他用户近能进入该目录，却无法读取任何数据。 drwx——: 除了目录所有者具有完整的权限之外，其他用户对该目录完全没有任何权限。 每个用户都拥有自己的专属目录，通常集中放置在/home目录下，这些专属目录的默认权限为rwx——: 表示目录所有者本身具有所有权限，其他用户无法进入该目录。执行mkdir命令所创建的目录，其默认权限为rwxr-xr-x,用户可以根据需要修改目录的权限。 此外，默认的权限可用umask命令修改，用法非常简单，只需执行umask 777 命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成000，依次类推。通常root帐号搭配umask命令的数值为022、027和 077，普通用户则是采用002，这样所产生的权限依次为755、750、700、775。有关权限的数字表示法，后面将会详细说明。 用户登录系统时，用户环境就会自动执行rmask命令来决定文件、目录的默认权限。特殊权限其实文件与目录设置不止这些，还有所谓的特殊权限。由于特殊权限会拥有一些“特权”，因而用户若无特殊需求，不应该启用这些权限，避免安全方面出现严重漏洞，造成黑客入侵，甚至摧毁系统!!! s或S（SUID,Set UID）：可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。 s或S（SGID，Set GID）：设置在文件上面，其效果与SUID相同，只不过将文件所有者换成用户组，该文件就可以任意存取整个用户组所能使用的系统资源。 T或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。 因为SUID、SGID、Sticky占用x的位置来表示，所以在表示上会有大小写之分。加入同时开启执行权限和SUID、SGID、Sticky，则权限表示字符是小写的： -rwsr-sr-t 1 root root 4096 6月 23 08：17 conf 如果关闭执行权限，则表示字符会变成大写： -rwSr-Sr-T 1 root root 4096 6月 23 08：17 conf使用文件管理器来改变文件或目录的权限如果用户要改变一个文件目录的权限，右击要改变权限的文件或者目录，在弹出的快捷菜单中选择“属性”，系统将打开属性对话框 在“属性”对话框中，单击“权限”标签，就会打开“权限”选项卡。 在这里你可以修改文件或者目录的所有者、组群和其他用户的权限，而且可以设置特殊权 对于特殊权限，最好不要设置，不然会带来很严重的安全问题。 当然，在这里你也可以改变文件和目录的所有者和所属组。使用chmod和数字改变文件或目录的访问权限文件和目录的权限表示，是用rwx这三个字符来代表所有者、用户组和其他用户的权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需三个数字。 r: 对应数值4 w: 对应数值2 x：对应数值1 -：对应数值0 数字设定的关键是mode的取值，一开始许多初学者会被搞糊涂，其实很简单，我们将rwx看成二进制数，如果有则有1表示，没有则有0表示，那么rwx r-x r--则可以表示成为： 111 101 100 再将其每三位转换成为一个十进制数，就是754。 例如，我们想让a.txt这个文件的权限为： 自己 同组用户 其他用户可读 是 是 是可写 是 是可执行 那么，我们先根据上表得到权限串为：rw-rw-r–，那么转换成二进制数就是110 110 100，再每三位转换成为一个十进制数，就得到664，因此我 们执行命令： [root@localhost ~]# chmod 664 a.txt 按照上面的规则，rwx合起来就是4+2+1＝7，一个rwxrwxrwx权限全开放的文件，数值表示为777；而完全不开放权限的文件“－－－－－－－－－”其数字表示为000。下面举几个例子：12345-rwx------:等于数字表示700。-rwxr―r--:等于数字表示744。-rw-rw-r-x:等于数字表示665。drwx―x―x:等于数字表示711。drwx------:等于数字表示700。 在文本模式下，可执行chmod命令去改变文件和目录的权限。我们先执行ls -l 看看目录内的情况：123456789101112[root@localhost ~]# ls -l总用量 368-rw-r--r-- 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到当然文件conkyrc.sample文件的权限是644,然后把这个文件的权限改成777。执行下面命令 [root@localhost ~]# chmod 777 conkyrc.sample 然后ls -l看一下执行后的结果：123456789101112[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到conkyrc.sample文件的权限已经修改为rwxrwxrwx 如果要加上特殊权限，就必须使用4位数字才能表示。特殊权限的对应数值为： s或 S （SUID）：对应数值4。 s或 S （SGID）：对应数值2。 t或 T ：对应数值1。 用同样的方法修改文件权限就可以了 例如：12345678910111213[root@localhost ~]# chmod 7600 conkyrc.sample[root@localhost ~]# ls -l总用量 368-rwS--S--T 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 加入想一次修改某个目录下所有文件的权限，包括子目录中的文件权限也要修改，要使用参数－R表示启动递归处理。 例如：12[root@localhost ~]# chmod 777 /home/user 注：仅把/home/user目录的权限设置为rwxrwxrw[root@localhost ~]# chmod -R 777 /home/user 注：表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx 使用命令chown改变目录或文件的所有权文件与目录不仅可以改变权限，其所有权及所属用户组也能修改，和设置权限类似，用户可以通过图形界面来设置，或执行chown命令来修改。 我们先执行ls -l看看目录情况：123456789101112[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到conkyrc.sample文件的所属用户组为root，所有者为root。执行下面命令，把conkyrc.sample文件的所有权转移到用户user:12345678910111213[root@localhost ~]# chown user conkyrc.sample[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 user root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 要改变所属组，可使用下面命令：12345678910111213[root@localhost ~]# chown :users conkyrc.sample[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 user users 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 要修改目录的权限，使用－R参数就可以了，方法和前面一样。 linux面试 如何暂停一个正在运行的进程，让其在后台运行？ 答案：为了停止正在运行的进程，让其在后台运行，我们可以使用组合键 Ctrl+Z。 什么是安装Linux所需的最小分区数量，以及如何查看系统启动信息？ 答案：单独一个/root分区足以执行所有的系统任务，但是强烈建议安装Linux时，需要至少三个分区：/root,/boot,/swap。一个IDE硬盘驱动器支持高达63个分区，SCSI硬盘驱动器支持超过15个分区。为了检查启动信息，我们可以使用cat或者dmesg命令，如下所示：#cat /var/log/messages或者#dmesg 在你的Linux机器上跟踪系统事件的守护进程名是什么？ 答案：’syslogd’，它负责跟踪系统信息，并将跟踪日志存储在特定的日志文件里。 在/root分区运行’fsck’命令的最低要求是什么？ 答案：/root分区必须挂载为只读模式，而不是读写模式 如何分层复制/home目录到另一个目录？ 答案：Linux的’cpio’命令起到了效果。’cpio’可以分层地复制文件和目录层次结构到另一个位置。 在Linux中，怎样实现日志文件的自动替换？ 答案：’logrotate’提供日志自动替换功能。 怎样知道Linux中是谁在安排工作？ 答案：使用’at’命令加上’-l’选项，就可以查出。 如何在不解压tar包的前提下，查看包里的内容？ 答案：使用’tar -tvf’。选项‘t’(显示内容)，‘v’（详细报告tar处理的文件信息），‘f’（使用档案文件或者设备） 什么是页面错误，它是怎么发生的？ 答案：当一个程序请求内存中不存在的数据时，就会产生页面错误，导致的结果就是程序停止。 什么是在程序中返回代码？ 答案：返回代码是shell的特性。返回代码显示了程序的状态，一个成功的程序执行后返回‘0’，&amp;&amp;可以用来决定那个应用程序先执行 问： 当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？答：可以使用bind命令，bind可以很方便地在shell中实现宏或按键的绑定。在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。比如获取F12的字符序列获取方法如下：先按下Ctrl+V,然后按下F12 .我们就可以得到F12的字符序列 ^[[24~。接着使用bind进行绑定。 [root@localhost ~]# bind ‘”\e[24~”:”date”‘注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。【附】也可以使用showkey -a命令查看按键对应的字符序列。推荐阅读：不同应用场景的10个Linux面试问题与解答 http://www.linuxidc.com/Linux/2014-04/99710.htm 问： 如果一个linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？答： 使用命令compgen ­-c，可以打印出所有支持的命令列表。 问：如果你的助手想要打印出当前的目录栈，你会建议他怎么做？答：使用Linux 命令dirs可以将当前的目录栈打印出来。[root@localhost ~]# dirs/usr/share/X11【附】：目录栈通过pushd popd 来操作。 问： 你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？答： 使用linux命令 ’disown -r ’可以将所有正在运行的进程移除。 问： bash shell 中的hash 命令有什么作用？答：linux命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。[root@localhost ~]# hashhits command2 /bin/ls2 /bin/su 常用命令123456789101112131415ls 列出当前目录文件（不包括隐含文件） ls -a 列出当前目录文件（包括隐含文件） ls -l 列出当前目录下文件的详细信息 cd .. 回当前目录的上一级目录 cd - 回上一次所在的目录 cd ~ 或 cd 回当前用户的宿主目录 mkdir 目录名 创建一个目录 rmdir 空目录名 删除一个空目录 rm 文件名 文件名 删除一个文件或多个文件 rm -rf 非空目录名 删除一个非空目录下的一切 mv 路经/文件 /经/文件移动相对路经下的文件到绝对路经下 mv 文件名 新名称 在当前目录下改名 find 路经 -name “字符串” 查找路经所在范围内满足字符串匹配的文件和目录 系统管理12345678910111213141516171819202122232425262728293031fdisk fdisk -l 查看系统分区信息 fdisk fdisk /dev/sdb 为一块新的SCSI硬盘进行分区 chown chown root /home 把/home的属主改成root用户 chgrp chgrp root /home 把/home的属组改成root组 Useradd 创建一个新的用户 Groupadd 组名 创建一个新的组 Passwd 用户名 为用户创建密码 Passwd -d用户名 删除用户密码也能登陆 Passwd -S用户名 查询账号密码 Usermod -l 新用户名 老用户名 为用户改名 Userdel–r 用户名 删除用户一切 service [servicename] start/stop/restart 系统服务控制操作 /etc/init.d/[servicename] start/stop/restart 系统服务控制操作 uname -a 查看内核版本 cat /etc/issue 查看ubuntu版本 lsusb 查看usb设备 sudo ethtool eth0 查看网卡状态 cat /proc/cpuinfo 查看cpu信息 lshw 查看当前硬件信息 sudo fdisk -l 查看磁盘信息 df -h 查看硬盘剩余空间 free -m 查看当前的内存使用情况 ps -A 查看当前有哪些进程 kill 进程号(就是ps -A中的第一列的数字)或者 killall 进程名( 杀死一个进程) kill -9 进程号 强制杀死一个进程 reboot Init 6 重启LINUX系统 Halt Init 0 Shutdown –h now 关闭LINUX系统 打包/解压12345tar -c 创建包 –x 释放包 -v 显示命令过程 –z 代表压缩包 tar –cvf benet.tar /home/benet 把/home/benet目录打包 tar –zcvf benet.tar.gz /mnt 把目录打包并压缩 tar –zxvf benet.tar.gz 压缩包的文件解压恢复 tar –jxvf benet.tar.bz2 解压缩 make编译12make 编译 make install 安装编译好的源码包 apt命令123456789101112131415161718apt-cache search package 搜索包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package 安装包 sudo apt-get install package - - reinstall 重新安装包 sudo apt-get -f install 修复安装”-f = –fix-missing” sudo apt-get remove package 删除包 sudo apt-get remove package - - purge 删除包，包括删除配置文件等 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-get dselect-upgrade 使用 dselect 升级 apt-cache depends package 了解使用依赖 apt-cache rdepends package 是查看该包被哪些包依赖 sudo apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 sudo apt-get clean 清理所有软件缓存（即缓存在/var/cache/apt/archives目录里的deb包） 查看软件xxx安装内容#dpkg -L xxx 查找软件#apt-cache search 正则表达式查找文件属于哪个包#dpkg -S filename apt-file search filename 查询软件xxx依赖哪些包#apt-cache depends xxx 查询软件xxx被哪些包依赖#apt-cache rdepends xxx 增加一个光盘源#sudo apt-cdrom add 系统升级123#sudo apt-get update #sudo apt-get upgrade #sudo apt-get dist-upgrade 清除所以删除包的残余配置文件#dpkg -l |grep ^rc|awk ‘{print $2}’ |tr [&quot;\n&quot;] [&quot; “]|sudo xargs dpkg -P - 编译时缺少h文件的自动处理#sudo auto-apt run ./configure 查看安装软件时下载包的临时存放目录#ls /var/cache/apt/archives 备份当前系统安装的所有包的列表#dpkg –get-selections | grep -v deinstall &gt; ~/somefile 从上面备份的安装包的列表文件恢复所有包#dpkg –set-selections &lt; ~/somefile sudo dselect 清理旧版本的软件缓存#sudo apt-get autoclean 清理所有软件缓存 #sudo apt-get clean 删除系统不再使用的孤立软件 #sudo apt-get autoremove 查看包在服务器上面的地址 #apt-get -qq –print-uris install ssh | cut -d\’ -f2 系统查看内核 #uname -a 查看Ubuntu版本 #cat /etc/issue 查看内核加载的模块 #lsmod 查看PCI设备 #lspci 查看USB设备 #lsusb 查看网卡状态 #sudo ethtool eth0 查看CPU信息 #cat /proc/cpuinfo 显示当前硬件信息 #lshw 硬盘查看硬盘的分区 #sudo fdisk -l 查看IDE硬盘信息 #sudo hdparm -i /dev/hda 查看STAT硬盘信息 #sudo hdparm -I /dev/sda 或 #sudo apt-get install blktool #sudo blktool /dev/sda id 查看硬盘剩余空间 #df -h #df -H 查看目录占用空间 #du -hs 目录名 优盘没法卸载 #sync fuser -km /media/usbdisk 内存查看当前的内存使用情况 #free -m 进程查看当前有哪些进程 #ps -A 中止一个进程 #kill 进程号(就是ps -A中的第一列的数字) 或者 killall 进程名 强制中止一个进程(在上面进程中止不成功的时候使用) #kill -9 进程号 或者 killall -9 进程名 图形方式中止一个程序 #xkill 出现骷髅标志的鼠标，点击需要中止的程序即可 查看当前进程的实时状况 #top 查看进程打开的文件 #lsof -p 如何设置动态域名 #首先去http://www.3322.org申请一个动态域名 #然后修改 /etc/ppp/ip-up 增加拨号时更新域名指令 sudo vim /etc/ppp/ip-up #在最后增加如下行 w3m -no-cookie -dump 网络根据IP查网卡地址 #arping IP地址 查看当前IP地址 #ifconfig eth0 |awk ‘/inet/ {split($2,x,&quot;:&quot;);print x[2]}’ 查看当前外网的IP地址 #w3m -no-cookie -dumpwww.edu.cn|grep-o‘[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}’ #w3m -no-cookie -dumpwww.xju.edu.cn|grep-o’[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}’ #w3m -no-cookie -dump ip.loveroot.com|grep -o’[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}’ 查看当前监听80端口的程序 #lsof -i :80 查看当前网卡的物理地址 #arp -a | awk ‘{print $4}’ ifconfig eth0 | head -1 | awk ‘{print $5}’ 立即让网络支持nat #sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward #sudo iptables -t nat -I POSTROUTING -j MASQUERADE 查看路由信息 #netstat -rn sudo route -n 手工增加删除一条路由 #sudo route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 #sudo route del -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 修改网卡MAC地址的方法 #sudo ifconfig eth0 down 关闭网卡 #sudo ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE 然后改地址 #sudo ifconfig eth0 up 然后启动网卡 统计当前IP连接的个数 #netstat -na|grep ESTABLISHED|awk ‘{print $5}’|awk -F: ‘{print $1}’|sort|uniq -c|sort -r -n #netstat -na|grep SYN|awk ‘{print $5}’|awk -F: ‘{print $1}’|sort|uniq -c|sort -r -n 统计当前20000个IP包中大于100个IP包的IP地址 #tcpdump -tnn -c 20000 -i eth0 | awk -F “.&quot; ‘{print $1″.&quot;$2″.&quot;$3″.&quot;$4}’ | sort | uniq -c | sort -nr | awk ‘ $1 &gt; 100 ‘ 屏蔽IPV6 #echo “blacklist ipv6″ | sudo tee /etc/modprobe.d/blacklist-ipv6 服务添加一个服务 #sudo update-rc.d 服务名 defaults 99 删除一个服务 #sudo update-rc.d 服务名 remove 临时重启一个服务 #/etc/init.d/服务名 restart 临时关闭一个服务 #/etc/init.d/服务名 stop 临时启动一个服务 #/etc/init.d/服务名 start 设置配置默认Java使用哪个 #sudo update-alternatives –config java 修改用户资料 #sudo chfn userid 给apt设置代理 #export http_proxy=http://xx.xx.xx.xx:xxx 修改系统登录信息 #sudo vim /etc/motd 中文转换文件名由GBK为UTF8 #sudo apt-get install convmv convmv -r -f cp936 -t utf8 –notest –nosmart * 批量转换src目录下的所有文件内容由GBK到UTF8 #find src -type d -exec mkdir -p utf8/{} \; find src -type f -exec iconv -f GBK -t UTF-8 {} -o utf8/{} \; mv utf8/* src rm -fr utf8 转换文件内容由GBK到UTF8 #iconv -f gbk -t utf8 $i &gt; newfile 转换 mp3 标签编码 #sudo apt-get install python-mutagen find . -iname “*.mp3&quot; -execdir mid3iconv -e GBK {} \; 控制台下显示中文 #sudo apt-get install zhcon 使用时，输入zhcon即可 文件快速查找某个文件 #whereis filename #find 目录 -name 文件名 查看文件类型 #file filename 显示xxx文件倒数6行的内容 #tail -n 6 xxx 让tail不停地读地最新的内容 #tail -n 10 -f /var/log/apache2/access.log 查看文件中间的第五行（含）到第10行（含）的内容 #sed -n ‘5,10p’ /var/log/apache2/access.log 查找包含xxx字符串的文件 #grep -l -r xxx . 全盘搜索文件(桌面可视化) gnome-search-tool 查找关于xxx的命令 #apropos xxx man -k xxx 通过ssh传输文件 #scp -rp /path/filenameusername@remoteIP:/path #将本地文件拷贝到服务器上 #scp -rpusername@remoteIP:/path/filename/path #将远程文件从服务器下载到本地 查看某个文件被哪些应用程序读写 #lsof 文件名 把所有文件的后辍由rm改为rmvb #rename ’s/.rm$/.rmvb/’ * 把所有文件名中的大写改为小写 #rename ‘tr/A-Z/a-z/’ * 删除特殊文件名的文件，如文件名：–help.txt #rm — –help.txt 或者 rm ./–help.txt 查看当前目录的子目录 #ls -d */. 或 echo */. 将当前目录下最近30天访问过的文件移动到上级back目录 #find . -type f -atime -30 -exec mv {} ../back \; 将当前目录下最近2小时到8小时之内的文件显示出来 #find . -mmin +120 -mmin -480 -exec more {} \; 删除修改时间在30天之前的所有文件 #find . -type f -mtime +30 -mtime -3600 -exec rm {} \; 查找guest用户的以avi或者rm结尾的文件并删除掉 #find . -name ‘*.avi’ -o -name ‘*.rm’ -user ‘guest’ -exec rm {} \; 查找的不以java和xml结尾,并7天没有使用的文件删除掉 #find . ! -name *.java ! -name ‘*.xml’ -atime +7 -exec rm {} \; 统计当前文件个数 #ls /usr/bin|wc -w 统计当前目录个数 #ls -l /usr/bin|grep ^d|wc -l 显示当前目录下2006-01-01的文件名 #ls -l |grep 2006-01-01 |awk ‘{print $8}’ FTP上传下载文件工具-filezilla #sudo apt-get install filezilla filezilla无法列出中文目录？站点-&gt;字符集-&gt;自定义-&gt;输入：GBK 本地中文界面1）下载filezilla中文包到本地目录，如~/2）#unrar x Filezilla3_zhCN.rar3) 如果你没有unrar的话，请先安装rar和unrar #sudo apt-get install rar unrar #sudo ln -f /usr/bin/rar /usr/bin/unrar 4）先备份原来的语言包,再安装；实际就是拷贝一个语言包。 #sudo cp /usr/share/locale/zh_CN/filezilla.mo /usr/share/locale/zh_CN/filezilla.mo.bak #sudo cp ~/locale/zh_CN/filezilla.mo /usr/share/locale/zh_CN/filezilla.mo 5）重启filezilla,即可！ 解压缩解压缩 xxx.tar.gz #tar -zxvf xxx.tar.gz 解压缩 xxx.tar.bz2 #tar -jxvf xxx.tar.bz2 压缩aaa bbb目录为xxx.tar.gz #tar -zcvf xxx.tar.gz aaa bbb 压缩aaa bbb目录为xxx.tar.bz2 #tar -jcvf xxx.tar.bz2 aaa bbb 解压缩 RAR 文件1) 先安装 #sudo apt-get install rar unrar #sudo ln -f /usr/bin/rar /usr/bin/unrar 2) 解压 #unrar x aaaa.rar Nautilus显示隐藏文件Ctrl+h 显示地址栏Ctrl+l 特殊 URI 地址 computer:/// - 全部挂载的设备和网络 network:/// - 浏览可用的网络 burn:/// - 一个刻录 CDs/DVDs 的数据虚拟目录 smb:/// - 可用的 windows/samba 网络资源 x-nautilus-desktop:/// - 桌面项目和图标 file:///- 本地文件 trash:/// - 本地回收站目录 ftp:// - FTP 文件夹 ssh:// - SSH 文件夹 fonts:/// - 字体文件夹，可将字体文件拖到此处以完成安装 themes:/// - 系统主题文件夹 查看已安装字体在nautilus的地址栏里输入”fonts:///“，就可以查看本机所有的fonts 程序详细显示程序的运行信息 #strace -f -F -o outfile 日期和时间 设置日期 #date -s mm/dd/yy 设置时间 #date -s HH:MM 将时间写入CMOS #hwclock –systohc 读取CMOS时间 #hwclock –hctosys 从服务器上同步时间 #sudo ntpdate time.nist.gov #sudo ntpdate time.windows.com 控制台 不同控制台间切换Ctrl + ALT + ← Ctrl + ALT + → 指定控制台切换Ctrl + ALT + Fn(n:1~7) 控制台下滚屏SHIFT + pageUp/pageDown 控制台抓图 #setterm -dump n(n:1~7) 数据库mysql的数据库存放在地方 #/var/lib/mysql 从mysql中导出和导入数据 #mysqldump 数据库名 &gt; 文件名 #导出数据库 #mysqladmin create 数据库名 #建立数据库 #mysql 数据库名 &lt; 文件名 #导入数据库 忘了mysql的root口令怎么办 #sudo /etc/init.d/mysql stop #sudo mysqld_safe –skip-grant-tables #sudo mysqladmin -u user password ‘newpassword&quot; #sudo mysqladmin flush-privileges 修改mysql的root口令 #sudo mysqladmin -uroot -p password ‘你的新密码’ 其它下载网站文档 #wget -r -p -np -khttp://www.21cn.com · r：在本机建立服务器端目录结构；· -p: 下载显示HTML文件的所有图片；· -np：只下载目标站点指定目录及其子目录的内容；· -k: 转换非相对链接为相对链接。 如何删除Totem电影播放机的播放历史记录 #rm ~/.recently-used 如何更换gnome程序的快捷键点击菜单，鼠标停留在某条菜单上，键盘输入任意你所需要的键，可以是组合键，会立即生效； 如果要清除该快捷键，请使用backspace vim 如何显示彩色字符 #sudo cp /usr/share/vim/vimcurrent/vimrc_example.vim /usr/share/vim/vimrc 如何在命令行删除在会话设置的启动程序 #cd ~/.config/autostart rm 需要删除启动程序 如何提高wine的反应速度 #sudo sed -ie ‘/GBK/,/^}/d’ /usr/share/X11/locale/zh_CN.UTF-8/XLC_LOCALE #chgrp[语法]: chgrp [-R] 文件组 文件…[说明]： 文件的GID表示文件的文件组，文件组可用数字表示， 也可用一个有效的组名表示，此命令改变一个文件的GID，可参看chown。-R 递归地改变所有子目录下所有文件的存取模式[例子]: #chgrp group file 将文件 file 的文件组改为 group #chmod[语法]: chmod [-R] 模式 文件…或 chmod [ugoa] {+|-|=} [rwxst] 文件…[说明]: 改变文件的存取模式，存取模式可表示为数字或符号串，例如： #chmod nnnn file ， n为0-7的数字，意义如下: 4000 运行时可改变UID2000 运行时可改变GID1000 置粘着位0400 文件主可读0200 文件主可写0100 文件主可执行0040 同组用户可读0020 同组用户可写0010 同组用户可执行0004 其他用户可读0002 其他用户可写0001 其他用户可执行nnnn 就是上列数字相加得到的，例如 chmod 0777 file 是指将文件 file 存取权限置为所有用户可读可写可执行。-R 递归地改变所有子目录下所有文件的存取模式u 文件主g 同组用户o 其他用户a 所有用户 增加后列权限 取消后列权限= 置成后列权限r 可读w 可写x 可执行s 运行时可置UIDt 运行时可置GID[例子]: #chmod 0666 file1 file2 将文件 file1 及 file2 置为所有用户可读可写 #chmod u+x file 对文件 file 增加文件主可执行权限 #chmod o-rwx 对文件file 取消其他用户的所有权限 #chown[语法]: chown [-R] 文件主 文件…[说明]: 文件的UID表示文件的文件主，文件主可用数字表示， 也可用一个有效的用户名表示，此命令改变一个文件的UID，仅当此文件的文件主或超级用户可使用。-R 递归地改变所有子目录下所有文件的存取模式[例子]: #chown mary file 将文件 file 的文件主改为 mary #chown 150 file 将文件 file 的UID改为150 Ubuntu命令行下修改网络配置以eth0为例 以DHCP方式配置网卡编辑文件/etc/network/interfaces: #sudo vi /etc/network/interfaces并用下面的行来替换有关eth0的行: The primary network interface - use DHCP to find our addressauto eth0iface eth0 inet dhcp用下面的命令使网络设置生效: #sudo /etc/init.d/networking restart 当然,也可以在命令行下直接输入下面的命令来获取地址 #sudo dhclient eth0 为网卡配置静态IP地址编辑文件/etc/network/interfaces:#sudo vi /etc/network/interfaces并用下面的行来替换有关eth0的行: The primary network interfaceauto eth0iface eth0 inet staticaddress 192.168.3.90gateway 192.168.3.1netmask 255.255.255.0network 192.168.3.0broadcast 192.168.3.255将上面的ip地址等信息换成你自己就可以了. 用下面的命令使网络设置生效: #sudo /etc/init.d/networking restart 设定第二个IP地址(虚拟IP地址)编辑文件/etc/network/interfaces: #sudo vi /etc/network/interfaces在该文件中添加如下的行: 1234567auto eth0:1 iface eth0:1 inet static address 192.168.1.60 netmask 255.255.255.0 network x.x.x.x broadcast x.x.x.x gateway x.x.x.x 根据你的情况填上所有诸如address,netmask,network,broadcast和gateways等信息.用下面的命令使网络设置生效: #sudo /etc/init.d/networking restart 设置主机名称(hostname)使用下面的命令来查看当前主机的主机名称: #sudo /bin/hostname使用下面的命令来设置当前主机的主机名称: #sudo /bin/hostname newname系统启动时,它会从/etc/hostname来读取主机的名称. 配置DNS首先,你可以在/etc/hosts中加入一些主机名称和这些主机名称对应的IP地址,这是简单使用本机的静态查询.要访问DNS 服务器来进行查询,需要设置/etc/resolv.conf文件.假设DNS服务器的IP地址是192.168.3.2, 那么/etc/resolv.conf文件的内容应为:search test.comnameserver 192.168.3.2 安装AMP服务如果采用Ubuntu Server CD开始安装时，可以选择安装，这系统会自动装上apache2,php5和mysql5。下面主要说明一下如果不是安装的Ubuntu server时的安装方法。用命令在Ubuntu下架设Lamp其实很简单，用一条命令就完成。在终端输入以下命令： #sudo apt-get install apache2 mysql-server php5 php5-mysql php5-gd #phpmyadmin装好后，mysql管理员是root，无密码，通过http://localhost/phpmyadmin就可以访问mysql了 修改 MySql 密码终端下输入： #mysql -u root #mysql&gt; GRANT ALL PRIVILEGES ON *.* TO root@localhost IDENTIFIED BY “123456″; ’123456‘是root的密码，可以自由设置，但最好是设个安全点的。 #mysql&gt; quit; 退出mysql apache2的操作命令启动：#sudo /etc/init.d/apache2 start重启：#sudo /etc/init.d/apache2 restart关闭：#sudo /etc/init.d/apache2 stopapache2的默认主目录：/var/www/ Ubuntu 7.10 更换软件源、更新系统网通建议用台湾的源，电信就用cn99在终端输入: #sudo gedit /etc/apt/sources.list Ubuntu.cn99.com 更新服务器（江苏省常州市电信，推荐电信用户使用。）deb http://ubuntu.cn99.com/ubuntu/ gutsy main restricted universe multiversedeb http://ubuntu.cn99.com/ubuntu/ gutsy-security main restricted universe multiversedeb http://ubuntu.cn99.com/ubuntu/ gutsy-updates main restricted universe multiverse mirror.rootguide.org更新服务器 (上海市 电信):deb http://mirror.rootguide.org/ubuntu/ gutsy main restricted universe multiversedeb-src http://mirror.rootguide.org/ubuntu/ gutsy main restricted universe multiversedeb http://mirror.rootguide.org/ubuntu/ gutsy-updates main restricted universe multiverse Mirror.lupaworld.com 更新服务器（浙江省杭州市电信，亚洲地区官方更新服务器）deb http://cn.archive.ubuntu.com/ubuntu gutsy main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu gutsy-security main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu gutsy-updates main restricted universe multiverse ubuntu.cnsite.org 更新服务器（福建省福州市 电信）deb http://ubuntu.cnsite.org/ubuntu/ gutsy main restricted universe multiversedeb-src http://ubuntu.cnsite.org/ubuntu/ gutsy main restricted universe multiversedeb http://ubuntu.cnsite.org/ubuntu/ gutsy-updates main restricted universe multiverse #清华大学 更新服务器（教育网，推荐校园网和网通用户使用）deb http://mirror9.net9.org/ubuntu/ gutsy main multiverse restricted universedeb http://mirror9.net9.org/ubuntu/ gutsy-backports main multiverse restricted universedeb http://mirror9.net9.org/ubuntu/ gutsy-proposed main multiverse restricted universe将里面乱七八糟的东西删了，将你复制的源列表粘贴到里面，保存退出。在终端输入 #sudo apt-get update #sudu apt-get upgrade 这样便更新以及升级了系统。 桌面汉化：System&gt;Language Support&gt;Chinese选项勾打上。 安装解码器、flashplayer、java虚拟机、微软字体这是ubuntu推出的一个新软件包，将一次性将上面几个东东自动装好在终端输入 #sudo apt-get install ubuntu-restricted-extras FireFox 中安装 FlashPlayer 插件先下载插件: install_flash_player_9_linux.tar.gz #tar -zxf install_flash_player_9_linux.tar.gz #./flashplayer-installer 回答(y/n/q)? n/q #sudo cp libflashplayer.so /usr/lib/firefox/plugins 启动 firefox 即可！ 安装媒体播放器安装的是mplayer终端输入：#sudo apt-get install mplayer mozilla-mplayer totem-xine libxine-extracodecs 另外需要一个w32codecs文件，是用来支持那些私有媒体格式的解码器，源里已经没有w32codecs了，我们可以从这里下载那个后缀为.deb的安装http://www.debian-multimedia.org/pool/main/w/w32codecs/ mplayer调试(视频、字幕)启动mplayer,右键－&gt;Preferences－&gt;VideoAvailable drivers选择xv然后进入Font标签 Font里选择一个中文字体，Encoding里设置为Simplified Chinese charset (CP936) 安装下载工具（多线程下载、BT下载、电驴）还是终端输入：#sudo apt-get install d4x amule azureus即可。或者把 beryl-manager添加到启动项内 字体更换我推荐大家使用文泉驿字体，在http://wqy.sourceforge.net下载deb包安装在“系统“－&gt;”首选项“－&gt;”字体“中调整字体 apt下载的deb包清理在使用完apt后，系统下载的deb包会留存在硬盘里，我们可以把它们删除，释放硬盘空间。终端输入：#sudo apt-get clean 安装rar压缩、解压工具终端输入：#sudo apt-get install rar unrar 启用root（最高权限）帐户终端输入：#sudo passwd root输入你希望的root用户的密码 安装QQ终端输入：#sudo apt-get install eva便可安装eva了，如果你是使用scim(选择中文语言支持的自动安装的就是scim)，为了可以在eva里面输入文字，要在终端输入：sudo apt-get install scim-qtimm系统会安装支持QT的scim插件，这样你就可以使用eva聊qq了。 显卡驱动安装进入“系统”－&gt;“系统管理”－&gt;“受限驱动管理器”找到你的显卡，把那个框点成对号，会提示你安装显卡驱动，然后按照提示一步一步安装完毕，重启即可。 beryl的安装你的系统在安装完毕之后就已经有了一个内置的桌面效果软件（能实现简单的桌面特效，包括3D立方体），使用方法是（必须将显卡驱动装好）进入“系统”“首选项”“桌面效果”，点击“启用桌面效果”，如果你需要使用3D立方体桌面，那么选中“立方体上的工作区”即可。如果你对这个简单的桌面特效工具不太满意，想追求更华丽的桌面，那么安装beryl仍然是个很好的选择。如今安装beryl不会像以前一样麻烦了，feisty的源里已经有了beryl的软件包，我们只需要在终端里输入： #sudo apt-get install beryl-core beryl-plugins beryl-plugins-data emerald beryl-settings beryl-manager beryl beryl-dev emerald-themes 安装完毕即可了。启动方法：“应用程序”－&gt;”系统工具”－&gt;”Beryl Manager”或者直接在终端输入：#beryl-manager 如何设定/改变/启用 root 使用者的密码? #sudo passwd root 为了启用 root 帐号 (也就是 设置一个口令) 使用: #sudo passwd root 当你使用完毕后屏蔽 root 帐号 使用: #sudo passwd -l root这个将锁住 root 帐号. 如何在终端机模式下切换到 root 身份? #sudo -s -HPassword: &lt;在这注明您的密码&gt; 安装VNC server第一步, 获取安装文件 #sudo apt-get install vnc4server 第二步, 修改VNC Password, 6-8位 #vncpasswd Password: **Verify:*第三步, 修改配置系统-&gt;首选项-&gt;远程桌面选择-&gt;请求用户输入此密码-&gt;输入至少6位密码第四步, 启动VNC server #vncserver 第五步，通过客户端连接 #vncviewer 192.168.0.1 安装MS字体 #sudo apt-get install msttcorefonts vim配置1) 首先安装 vim 完整版本 #sudo apt-get install vim-full 2) vim中文在线帮助a. 先下载文档 vimcdoc-1.5.0.tar.gzb. 解压, 执行./vimcdoc.sh, vi里面, 执行:help, 就都是中文的了. 3) 启用本地配置 VIM version 7.1 (说明文档) #cp etc/vim/vimrc ~/.vimrc #vim ~/.vimrc “””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 一般设定“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 设定默认解码set fenc=utf-8set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936“ 不要使用vi的键盘模式，而是vim自己的set nocompatible “ history文件中需要记录的行数set history=100 “ 在处理未保存或只读文件的时候，弹出确认set confirm “ 与windows共享剪贴板set clipboard+=unnamed “ 侦测文件类型filetype on “ 载入文件类型插件filetype plugin on “ 为特定文件类型载入相关缩进文件filetype indent on “ 保存全局变量set viminfo+=! “ 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,- “ 语法高亮syntax on “ 高亮字符，让其不受100列限制:highlight OverLength ctermbg=red ctermfg=white guibg=red guifg=white:match OverLength ‘\%101v.*’ “ 状态行颜色highlight StatusLine guifg=SlateBlue guibg=Yellowhighlight StatusLineNC guifg=Gray guibg=White “””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 文件设置“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 不要备份文件（根据自己需要取舍）set nobackup “ 不要生成swap文件，当buffer被丢弃的时候隐藏它setlocal noswapfileset bufhidden=hide “ 字符间插入的像素行数目set linespace=0 “ 增强模式中的命令行自动完成操作set wildmenu “ 在状态行上显示光标所在位置的行号和列号set rulerset rulerformat=%20(%2*%&lt;%f%=\ %m%r\ %3l\ %c\ %p%%%) “ 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2 “ 使回格键（backspace）正常处理indent, eol, start等set backspace=2 “ 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l “ 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key “ 启动的时候不显示那个援助索马里儿童的提示set shortmess=atI “ 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0 “ 不让vim发出讨厌的滴滴声set noerrorbells “ 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\ “””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 搜索和匹配“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 高亮显示匹配的括号set showmatch “ 匹配括号高亮的时间（单位是十分之一秒）set matchtime=5 “ 在搜索的时候忽略大小写set ignorecase “ 不要高亮被搜索的句子（phrases）set nohlsearch “ 在搜索时，输入的词句的逐字符高亮（类似firefox的搜索）set incsearch “ 输入:set list命令是应该显示些啥？set listchars=tab:|\ ,trail:.,extends:&gt;,precedes:&lt;,eol:$ “ 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3 “ 不要闪烁set novisualbell “ 我的状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\”%d/%m/%y\ -\ %H:%M\”)} “ 总是显示状态行set laststatus=2 “””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 文本格式和排版“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 自动格式化set formatoptions=tcrqn “ 继承前一行的缩进方式，特别适用于多行注释set autoindent “ 为C程序提供自动缩进set smartindent “ 使用C样式的缩进set cindent “ 制表符为4set tabstop=4 “ 统一缩进为4set softtabstop=4set shiftwidth=4 “ 不要用空格代替制表符set noexpandtab “ 不要换行set nowrap “ 在行和段开始处使用制表符set smarttab “””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ CTags的设定“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 按照名称排序let Tlist_Sort_Type = “name” “ 在右侧显示窗口let Tlist_Use_Right_Window = 1 “ 压缩方式let Tlist_Compart_Format = 1 “ 如果只有一个buffer，kill窗口也kill掉bufferlet Tlist_Exist_OnlyWindow = 1 “ 不要关闭其他文件的tagslet Tlist_File_Fold_Auto_Close = 0 “ 不要显示折叠树let Tlist_Enable_Fold_Column = 0 “””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ Autocommands“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 只在下列文件类型被侦测到的时候显示行号，普通文本文件不显示 if has(“autocmd”)autocmd FileType xml,html,c,cs,java,perl,shell,bash,cpp,python,vim,php,ruby set numberautocmd FileType xml,html vmap]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate相关知识]]></title>
    <url>%2F2016%2F11%2F10%2Fhibernate%2F</url>
    <content type="text"><![CDATA[介绍Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 Hibernate映射(ORM对象关系映射)多和一的映射12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- 员工表的映射配置 --&gt;&lt;hibernate-mapping package=&quot;cn.hpe.po&quot; &gt;&lt;class name=&quot;Employee&quot; table=&quot;t_employee&quot;&gt;&lt;!-- 主键 --&gt;&lt;id name=&quot;empId&quot; column=&quot;empid&quot; &gt;&lt;!-- 如果此处class设置伟sequence或者native,那么实体类的主键属性必须时int,若是String类型，class必须是uuid --&gt;&lt;generator class=&quot;sequence&quot;&gt;&lt;param name=&quot;sequence&quot;&gt;seq_emp_empid&lt;/param&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name=&quot;empName&quot; length=&quot;50&quot;&gt;&lt;/property&gt;&lt;property name=&quot;salary&quot; type=&quot;double&quot;&gt;&lt;/property&gt;&lt;!-- 多对一 映射的另外一张t_dept表 ,dept_id 和 dept表的 映射的外键key标签的属性都是dept_id --&gt;&lt;many-to-one name=&quot;dept&quot; class=&quot;Dept&quot; column=&quot;dept_id&quot; &gt;&lt;/many-to-one&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt;&lt;!-- 部门表的 映射配置 --&gt;&lt;hibernate-mapping package=&quot;cn.hpe.po&quot; auto-import=&quot;true&quot;&gt;&lt;class name=&quot;Dept&quot; table=&quot;t_dept&quot;&gt;&lt;!-- 主键 --&gt;&lt;id name=&quot;deptId&quot; column=&quot;deptid&quot; &gt;&lt;!-- 如果此处class设置伟sequence或者native,那么实体类的主键属性必须时int,若是String类型，class必须是uuid --&gt;&lt;generator class=&quot;sequence&quot; &gt;&lt;param name=&quot;sequence&quot;&gt;seq_dept_deptid&lt;/param&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name=&quot;deptName&quot; length=&quot;50&quot;&gt;&lt;/property&gt;&lt;!--set 集合属性映射name 指定要映射的set集合的属性table 集合属性要映射到的表key 指定集合表（t_employee）的外键字段element 指定集合表的其他字段type 元素类型，一定要指定--&gt;&lt;!--一对多 映射的另外一张t_employee表 ；inverse默认false，不控制反转，说明当前方具有控制权;inverse=true,说明没有控制权，没有控制权不能进行关系解除和删除数据cascade的值 ：none（默认），(save-update)，(seve-update,delete 一定要有 逗号)，（all 所有但不包括默认none）cascade=none,默认不级联操作，所谓级联就是操作某个表数据同时也会操作另外关联的表的数据面试题：inverse和cascade的关系： 当设置inverse=true时cascade也可以进行级联删除--&gt;&lt;set name=&quot;emps&quot; table=&quot;t_employee&quot; inverse=&quot;false&quot; cascade=&quot;none&quot;&gt;&lt;!-- 配置外键字段 --&gt;&lt;key column=&quot;dept_id&quot;&gt;&lt;/key&gt;&lt;one-to-many class=&quot;Employee&quot;/&gt;&lt;/set&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; 一和一的映射12345678910111213141516171819202122232425262728&lt;!-- 身份证表映射 users 的 映射配置 --&gt;&lt;hibernate-mapping package=&quot;cn.hpe.po&quot;&gt;&lt;class name=&quot;IdCard&quot; table=&quot;t_idcard&quot;&gt;&lt;!-- 主键 --&gt;&lt;id name=&quot;cardNum&quot; column=&quot;cardid&quot; &gt;&lt;!-- 如果此处class设置assigned 指定主键生成策略，为手动指定主键的值 --&gt;&lt;generator class=&quot;assigned&quot;&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name=&quot;place&quot; length=&quot;100&quot;&gt;&lt;/property&gt;&lt;!-- 特殊的多对一映射，即一对一，有外键方，unique=true，设置外键唯一，此时外键也成了&apos;主键 &apos;，此配置是基于外键的配置--&gt;&lt;many-to-one name=&quot;users&quot; class=&quot;Users&quot; column=&quot;usersid&quot; unique=&quot;true&quot; cascade=&quot;save-update&quot;/&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt;&lt;!-- users用户信息的 映射配置 --&gt;&lt;hibernate-mapping package=&quot;cn.hpe.po&quot;&gt;&lt;class name=&quot;Users&quot; table=&quot;t_users&quot;&gt;&lt;!-- 主键 --&gt;&lt;id name=&quot;usersId&quot; column=&quot;usersid&quot; &gt;&lt;generator class=&quot;sequence&quot;&gt;&lt;param name=&quot;sequence&quot;&gt;seq_tusers_usersid&lt;/param&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name=&quot;userName&quot; length=&quot;50&quot;&gt;&lt;/property&gt;&lt;!-- 一对一映射，没有外键方 --&gt;&lt;one-to-one name=&quot;idCard1&quot; class=&quot;IdCard1&quot; /&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; 多和多的映射12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!-- 项目表的 映射配置 --&gt;&lt;hibernate-mapping package=&quot;cn.hpe.po&quot;&gt;&lt;class name=&quot;Project&quot; table=&quot;t_project&quot;&gt;&lt;!-- 主键 --&gt;&lt;id name=&quot;prjId&quot; column=&quot;prj_id&quot; &gt;&lt;!-- 如果此处class设置伟sequence或者native,那么实体类的主键属性必须时int,若是String类型，class必须是uuid --&gt;&lt;generator class=&quot;sequence&quot;&gt;&lt;param name=&quot;sequence&quot;&gt;seq_project_prjid&lt;/param&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name=&quot;prjName&quot; length=&quot;50&quot;&gt;&lt;/property&gt;&lt;!-- 多对多 映射的另外一张t_relation表 --&gt;&lt;set name=&quot;developers&quot; table=&quot;t_relation&quot; cascade=&quot;save-update&quot;&gt;&lt;!-- 配置外键字段 --&gt;&lt;key column=&quot;prj_id&quot;&gt;&lt;/key&gt;&lt;many-to-many class=&quot;Developer&quot; column=&quot;d_id&quot; &gt;&lt;/many-to-many&gt;&lt;/set&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt;&lt;!-- 开发人员表的 映射配置 --&gt;&lt;hibernate-mapping package=&quot;cn.hpe.po&quot;&gt;&lt;class name=&quot;Developer&quot; table=&quot;t_developer&quot;&gt;&lt;!-- 主键 --&gt;&lt;id name=&quot;dId&quot; column=&quot;d_id&quot; &gt;&lt;!-- 如果此处class设置伟sequence或者native,那么实体类的主键属性必须时int,若是String类型，class必须是uuid --&gt;&lt;generator class=&quot;sequence&quot;&gt;&lt;param name=&quot;sequence&quot;&gt;seq_developer_did&lt;/param&gt;&lt;/generator&gt;&lt;/id&gt;&lt;property name=&quot;dName&quot; length=&quot;50&quot;&gt;&lt;/property&gt;&lt;!--set 集合属性映射name 指定要映射的set集合的属性table 集合属性要映射到的表key 指定集合表（t_employee）的外键字段element 指定集合表的其他字段type 元素类型，一定要指定--&gt;&lt;!--多对多 映射的另外一张t_relation表 ；inverse默认false，不控制反转，说明当前方具有控制权;inverse=true,说明没有控制权，没有控制权不能进行关系解除和删除数据cascade的值 ：none（默认），(save-update)，(seve-update,delete 一定要有 逗号)，（all 所有但不包括默认none）cascade=none,默认不级联操作，所谓级联就是操作某个表数据同时也会操作另外关联的表的数据懒加载属性：lazy值：默认 true 设置懒加载false 关闭懒加载extra （更高级，经常使用这个属性）只有在使用的时候才去数据库取数据，防止只查询记录数的时候会把所有的数据查出来目的：提高效率--&gt;&lt;set name=&quot;projects&quot; table=&quot;t_relation&quot; cascade=&quot;save-update&quot; lazy=&quot;extra&quot;&gt;&lt;!-- 配置外键字段 --&gt;&lt;key column=&quot;d_id&quot;&gt;&lt;/key&gt;&lt;many-to-many class=&quot;Project&quot; column=&quot;prj_id&quot; &gt;&lt;/many-to-many&gt;&lt;/set&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; 懒加载及时加载–get()12345Developer developer = new Developer();// Hibernate: select developer0_.d_id as d1_0_0_, developer0_.dName as// dName0_0_ from t_developer developer0_ where developer0_.d_id=?// developer = (Developer) session.get(Developer.class, 1);// get及时加载，会把所有相关的字段查出来 懒加载–load()12345678// 懒加载，内部hibernate其实使用代理对象($Proxy01)进行懒加载，配置lazy=true。只是加载并没有执行数据库查询，没有sql语句输出developer = (Developer) session.load(Developer.class, 1);// 用到时才会查询数据库// Hibernate: select developer0_.d_id as d1_0_0_, developer0_.dName as// dName0_0_ from t_developer developer0_ where developer0_.d_id=?// 用到时才会查询数据库，输出：李四// System.out.println(developer.getdName()); 如何解决在session关闭后输出懒加载内容异常123456789101112// 方式1： 先使用一下数据// developer.getdName();// 方式2：强迫代理对象初始化Hibernate.initialize(developer);// 方式3：关闭懒加载 在映射文件中设置lazy=&quot;false&quot;// 获取事务并提交,这才是执行数据库操作session.getTransaction().commit();session.close();// 如何解决在session关闭后输出懒加载内容异常System.out.println(developer.getdName()); 一级缓存1234567891011Developer developer = null;developer = (Developer) session.get(Developer.class, 1);// 查询数据时先检查缓存中是否有数据，没有数据再从数据库查询developer = (Developer) session.get(Developer.class, 1);// 此时一级缓存中已经有数据// 查询数据时先检查缓存中是否有数据，没有数据再从数据库查询// 获取事务并提交,这才是执行数据库操作session.getTransaction().commit();session.close();// 执行一条sql语句，说明第一次查询时缓存中没有数据，然后放入缓存，接下来的又一次查询会直接从缓存中获取// Hibernate:select developer0_.d_id as d1_0_0_, developer0_.dName as// dName0_0_ from t_developer developer0_ where developer0_.d_id=? 测试缓存的方法有:123session.flush()//缓存中的数据同步到数据库中session.clear()//清空当前缓存session.evict(developer);// 清空指定对象object 二级缓存使用二级缓存的前提是在配置文件配置二级缓存,并指定哪些类会加入二级缓存1234567891011121314151617181920&lt;!-- ****************** 【二级缓存配置】 ****************** --&gt;&lt;!-- 开启二级缓存 --&gt;&lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;&lt;!-- 开启哪一个缓存框架 --&gt;&lt;property name=&quot;hibernate.cache.provider_class&quot;&gt;org.hibernate.cache.HashtableCacheProvider&lt;/property&gt;&lt;!-- 开启二级缓存中的缓存查询 --&gt;&lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;指定哪一些(常用的)类，需要加入二级缓存，二级缓存会消耗内存,查询速度快usage缓存策略：&lt;class-cache usage=&quot;read-write&quot; class=&quot;cn.hpe.po.Dept&quot;/&gt;&lt;!-- employee 集合也放入二级缓存查询 --&gt;&lt;class-cache usage=&quot;read-only&quot; class=&quot;cn.hpe.po.Employee&quot;/&gt;&lt;!-- 集合缓存[集合缓存的 元素 对象，也加入二级缓存，就是class=&quot;cn.hpe.po.Employee&quot;] --&gt;&lt;collection-cache usage=&quot;read-write&quot; collection=&quot;cn.hpe.po.Dept.emps&quot;/&gt;Dept dept = (Dept) session1.get(Dept.class, 1);//第一次查询,已经放入二级缓存...dept = (Dept) session2.get(Dept.class, 1);//另一个session来获取二级缓存的数据,不会从数据库查询... mappingLocations,mappingDirectoryLocations,mappingJarLocations区别由于spring对hibernate配置文件hibernate.cfg.xml的集成相当好，所以，在项目中我一直使用spring的org.springframework.orm.hibernate.LocalSessionFactoryBean来取代hibernate.cfg.xml文件的功能LocalSessionFactoryBean有好几个属性用来查找hibernate映射文件：mappingResources、mappingLocations、mappingDirectoryLocations与mappingJarLocations他们的区别：12345678910111213141516171819202122232425262728293031323334mappingResources：指定classpath下具体映射文件名&lt;property name=&quot;mappingResources&quot;&gt; &lt;value&gt;petclinic.hbm.xml &lt;/value&gt;&lt;/property&gt;mappingLocations：可以指定任何文件路径，并且可以指定前缀：classpath、file等&lt;property name=&quot;mappingLocations&quot;&gt; &lt;value&gt;/WEB-INF/petclinic.hbm.xml &lt;/value&gt;&lt;/property&gt;&lt;property name=&quot;mappingLocations&quot;&gt; &lt;value&gt;classpath:/com/company/domain/petclinic.hbm.xml &lt;/value&gt;&lt;/property&gt;也可以用通配符指定，&apos;*&apos;指定一个文件(路径)名，&apos;**&apos;指定多个文件(路径)名，例如：&lt;property name=&quot;mappingLocations&quot;&gt; &lt;value&gt;classpath:/com/company/domainmaps/*.hbm.xml &lt;/value&gt;&lt;/property&gt;上面的配置是在com/company/domain包下任何maps路径下的hbm.xml文件都被加载为映射文件 mappingDirectoryLocations：指定映射的文件路径 &lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;WEB-INF/HibernateMappings&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;也可以通过classpath来指出&lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:/XXX/package/&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;mappingJarLocations：指定加载的映射文件在jar文件中 关于java 这是利用Struts2里面的自动匹配特性。代表通配符，可以匹配任何一个字符串[1]表示匹配的参数。举个例子来说，如果你在xml文件中做了这个配置，那么当你页面里面有一个form&lt;form action=&quot;/emp-add&quot; method=&quot;post&quot;&gt;那么，匹配到的就是“add”,同时method=”{1}”，实际上就是method=”add”。假设有两个参数，我么在xml里面的配置是&lt;action name=&quot;emp-*-*&quot; class=&quot;{1}Action&quot; method=&quot;{2}&quot;&gt;那么第一个星号对应的是{1},第二个星号对应的是{2}例如，页面里面有&lt;form action=&quot;/emp-employee-add&quot; method=&quot;post&quot;&gt;那么实际上的意思就是&lt;action name=&quot;emp-employee-*&quot; class=&quot;employeeAction&quot; method=&quot;add&quot;&gt; 这样做的好处就是我们不必为增删改查资格方法写四个配置。同样如果有相似的逻辑，比如学生信息的增删改查和老师信息的增删改查逻辑是一样的，那么我们也可以通过通配符来节省xml文件中的代码量 前提是一定要遵守通配符的约定 struts运行机制（用户访问一个url）12index.jsp:&lt;c:redirect url=&quot;/employee_list&quot;&gt;&lt;/c:redirect&gt; 注意url struts.xml配置123456789101112131415&lt;!-- ### action 实例交给spring创建；链接传过来的地址在这进行处理 ， method=&quot;&#123;1&#125;&quot;就是匹配 ‘*’，就是方法的名字，如果url=&quot;/employee_list&quot;,则method=list， 自动去class=&quot;employeeAction&quot;（action实例），去类 EmployeeAction中找list()方法，执行后方法返回&quot;list&quot;字符串，对应name=&quot;list&quot;, 匹配后进入/WEB-INF/list.jsp--&gt; &lt;action name=&quot;employee_*&quot; class=&quot;employeeAction&quot; method=&quot;&#123;1&#125;&quot;&gt;//这行代码是第三步随后进入action类里执行后还返回这里才往下执行result name=&quot;list&quot;&gt;/WEB-INF/list.jsp&lt;/result&gt; &lt;!-- 1.列表展示，放在/WEB-INF 下面 --&gt; &lt;result name=&quot;list&quot;&gt;/WEB-INF/list.jsp&lt;/result&gt; &lt;!-- 2.进入添加页面，放在/WEB-INF 下面 --&gt; &lt;result name=&quot;add&quot;&gt;/WEB-INF/add.jsp&lt;/result&gt; &lt;!-- 3.添加成功，进入列表，（防止用户刷新多一条记录） --&gt; &lt;result name=&quot;listAction&quot; type=&quot;redirect&quot;&gt;employee_list&lt;/result&gt; &lt;!-- 4.修改员工数据，进入修改页面 --&gt; &lt;result name=&quot;edit&quot;&gt;/WEB-INF/edit.jsp&lt;/result&gt; &lt;/action&gt; EmployeeAction.java12345678910111213/** * 1. 员工列表展示 */ public String list() &#123; List&lt;Employee&gt; list = employeeService.getAll(); request.put(&quot;listEmp&quot;, list); return &quot;list&quot;;//返回到struts.xml中 &#125;&lt;result name=&quot;list&quot;&gt;/WEB-INF/list.jsp&lt;/result&gt;进入list.jsp页面 list.jsp显示页面123456789101112131415161718192021&lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;80%&quot; cellpadding=&quot;5&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;员工姓名&lt;/th&gt; &lt;th&gt;员工薪水&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;s:if test=&quot;#request.listEmp != null&quot;&gt; &lt;s:iterator var=&quot;emp&quot; value=&quot;#request.listEmp&quot; status=&quot;st&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;s:property value=&quot;#st.count&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;s:property value=&quot;#emp.employeeId&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;s:property value=&quot;#emp.employeeName&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;s:property value=&quot;#emp.employeeSalary&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;s:a href=&quot;employee_viewUpdate?employeeId=%&#123;#emp.employeeId&#125;&quot;&gt;修改 &lt;/s:a&gt; &lt;s:a href=&quot;employee_delete?employeeId=%&#123;#emp.employeeId&#125;&quot;&gt;删除 &lt;/s:a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/s:if&gt; struts登陆成功后用户信息保存到session用actionContextActionContext.getContext().getSession().put(&quot;adminInfo&quot;,adminInfo); config the follow in OracleEmployee.hbm.xml:1234567891011121314151617181920&lt;class name=&quot;Employee&quot; table=&quot;t_employee&quot;&gt; &lt;!-- 主键 --&gt; &lt;id name=&quot;empId&quot; column=&quot;empid&quot; type=&quot;string&quot;&gt; &lt;generator class=&quot;uuid&quot;&gt; (if you set class=&quot;native&quot;,the type of empId of class Employee must be int) &lt;param name=&quot;sequence&quot;&gt;seq_emp_empid&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;empName&quot; length=&quot;50&quot;&gt;&lt;/property&gt; &lt;property name=&quot;salary&quot; type=&quot;double&quot;&gt;&lt;/property&gt; &lt;!-- 多对一 映射的另外一张t_dept表 ,dept_id 和 dept表的 映射的外键key标签的属性都是dept_id --&gt; &lt;many-to-one name=&quot;dept&quot; class=&quot;Dept&quot; column=&quot;dept_id&quot;&gt;&lt;/many-to-one&gt; &lt;/class&gt;Employee: private String empId;// 员工编号 private String empName;// 姓名 private double salary;// 薪水 // 一个员工对应一个部门 private Dept dept;// 所属部门 if you set the type of empId String in Employee, you will set “ class=”uuid””and create table auto primary key: uuid 面试题 不同的session是否会共享缓存数据? 不会。 User1 u1 = Session1.get(User.class,1); 把u1对象放入session1的缓存 Session2.update(u1); 把u1放入session2的缓存 U1.setName(‘new Name’);如果生成2条update sql， 说明不同的session使用不同的缓存区，不能共享。 Hibernate –list与iterator查询的区别？ list()一次把所有的记录都查询出来，会放入缓存，但不会从缓存中获取数据IteratorN+1查询； N表示所有的记录总数即会先发送一条语句查询所有记录的主键（1），再根据每一个主键再去数据库查询（N）！ 缓存策略1234&lt;class-cache usage=&quot;read-only&quot;/&gt; 放入二级缓存的对象，只读; &lt;class-cache usage=&quot;nonstrict-read-write&quot;/&gt; 非严格的读写 &lt;class-cache usage=&quot;read-write&quot;/&gt; 读写；放入二级缓存的对象可以读、写； &lt;class-cache usage=&quot;transactional&quot;/&gt; (基于事务的策略) 缓存的机制：Map&lt;条件，对象&gt;hibernate工作流程：1️⃣ 读取并解析配置文件；2️⃣ Configuration负责读取并创建映射信息，创建sessionfactory；3️⃣ SessionFactory负责创建session；4️⃣ Transaction负责开启事物Transaction；5️⃣ Query负责执行持久化操作；6️⃣ Transaction负责提交实物；7️⃣ 关闭session；8️⃣ 关闭sessionfactory。 懒加载:代理对象内部hibernate其实使用代理对象($Proxy01)进行懒加载，配置lazy=true。只是加载并没有执行数据库查询，没有sql语句输出123456developer=(Developer)session.load(Developer.class,1);// 用到时才会查询数据库//Hibernate: select developer0_.d_id as d1_0_0_, developer0_.dName as// dName0_0_ from t_developer developer0_ where developer0_.d_id=?// 用到时才会查询数据库，输出：李四// System.out.println(developer.getdName()); hibernate分页12345678910111213141516171819publicvoidpage()&#123; Sessionsession=HibernateUtiles.getSession(); // 开始事务 session.beginTransaction(); Queryquery=session.createQuery(&quot;from Employee&quot;); // 总记录数--滚动结果集 ScrollableResultssResults=query.scroll();// 得到滚动的结果集 sResults.last();// 滚动到最后一行 inttotalRecords=sResults.getRowNumber()+1;// 获取总记录数 // 设置分页参数，输出2条记录 query.setFirstResult(2); query.setMaxResults(3); // 输出查询 System.out.println(query.list()); System.out.println(&quot;记录数&quot;+totalRecords); // 获取事务并提交,这才是执行数据库操作 session.getTransaction().commit(); session.close();&#125; hibernate连接查询–迫切连接12345678910111213@Testpublicvoidfetch()&#123; Sessionsession=HibernateUtiles.getSession(); // 开始事务 session.beginTransaction(); // 迫切 内连接，把右表的数据填充到左表，返回的类型就是左表的类型dept // Query query = session // .createQuery(&quot;fromDeptd inner join fetch d.emps&quot;); // query.list(); // 迫切 左外连接，把右表的数据填充到左表，返回的类型就是左表的类型dept // Query query = // session.createQuery(&quot;fromDeptd left join fetch d.emps&quot;); // query.list();]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring面试题综合]]></title>
    <url>%2F2016%2F11%2F01%2Finterview-questions%2F</url>
    <content type="text"><![CDATA[优化数据库1️⃣ 数据库查询使用索引2️⃣ 查询数据不使用*,使用具体字段3️⃣ 语句大写4️⃣ 使用exists代替in,not exists代替not in5️⃣ 用>=代替>6️⃣ 尽量使用commit,因为会释放一些资源 例如 回滚段上用于回复的数据 被程序语句获得的锁等 oracle管理这些资源的花费 外链接面试题大全 Oralce数据库的优化(面试必问题) 数据库常见面试题 SSh三大框架常考面试题简述hibernate工作原理及为什么要用？原理:1读取并解析配置文件2读取并解析映射信息，创建SessionFactory3打开Sesssion4创建事务Transation5持久化操作6提交事务7关闭Session8关闭SesstionFactory 为什么要用： 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Hibernate是如何延迟加载?1 Hibernate 延迟加载实现：a)实体对象 b)集合（Collection）2Hibernate 提供了属性的延迟加载功能，当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。3Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系) 类与类之间的关系主要体现在表与表之间的关系进行操作，它们都是对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、 说下Hibernate的缓存机制1️⃣ 内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存2️⃣ 二级缓存： 应用级缓存 分布式缓存条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据 第三方缓存的实现 Hibernate的查询方式Sql、Criteria、object comptositionHql： 属性查询 参数查询、命名参数查询 关联查询 分页查询 统计函数 如何优化Hibernate？ 使用双向一对多关联，不使用单向一对多 灵活使用单向一对多关联 不用一对一，用多对一取代 配置对象缓存，不使用集合缓存 继承类使用显式多态 表字段要少，表关联不要怕多，有二级缓存撑腰 spring为什么用： AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务 （比如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。 IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反 过来的JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight construction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象（collaborator）。 Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，如图 1 所示。组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。 IOC和AOP控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器（在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。下表列出了 IOC 的一个实现模式。Spring 框架的 IOC 容器采用类型 2 和类型3 实现。面向方面的编程面向方面的编程，即 AOP，是一种编程技术，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP 的核心构造是方面，它将那些影响多个类的行为封装到可重用的模块中。 AOP 和 IOC 是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和 Java 类中才能实现日志功能。在 AOP 方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是 Java 类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用 Spring AOP 编写的应用程序代码是松散耦合的。AOP 的功能完全集成到了 Spring 事务管理、日志和其他各种特性的上下文中。 IOC 容器Spring 设计的核心是 org.springframework.beans 包，它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是 BeanFactory 接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。BeanFactory 支持两个对象模型。□ 单态 模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton 是默认的也是最常用的对象模型。对于无状态服务对象很理想。□ 原型 模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。bean 工厂的概念是 Spring 作为 IOC 容器的基础。IOC 将处理事情的责任从应用程序代码转移到框架。正如我将在下一个示例中演示的那样，Spring 框架使用 JavaBean 属性和配置数据来指出必须设置的依赖关系。BeanFactory 接口因为 org.springframework.beans.factory.BeanFactory 是一个简单接口，所以可以针对各种底层存储方法实现。最常用的 BeanFactory 定义是 XmlBeanFactory，它根据 XML 文件中的定义装入 bean，如清单 1 所示。清单 1. XmlBeanFactoryBeanFactory factory = new XMLBeanFactory(new FileInputSteam(“mybean.xml”));在 XML 文件中定义的 Bean 是被消极加载的，这意味在需要 bean 之前，bean 本身不会被初始化。要从 BeanFactory 检索 bean，只需调用 getBean() 方法，传入将要检索的 bean 的名称即可，如清单 2 所示。 清单 2. getBean()MyBean mybean = (MyBean) factory.getBean(“mybean”);每个 bean 的定义都可以是 POJO （用类名和 JavaBean 初始化属性定义） 或 FactoryBean。FactoryBean 接口为使用 Spring 框架构建的应用程序添加了一个间接的级别。 Struts工作机制？为什么要使用Struts？工作机制：Struts的工作流程:在web应用启动时就会加载初始化ActionServlet,ActionServlet从struts-config.xml文件中读取配置信息,把它们存放到各种配置对象..当ActionServlet接收到一个客户请求时,将执行如下流程:1️⃣ 检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;2️⃣ 如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中;3️⃣ 根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法;4️⃣ 如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActionErrors对象, 就表示表单验证成功;5️⃣ ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的Action实例不存在,就先创建这个实例,然后调用Action的execute()方法;6️⃣ Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给ActionForward对象指向的JSP组件;7️⃣ ActionForward对象指向JSP组件生成动态网页,返回给客户; 为什么要用：JSP、Servlet、JavaBean技术的出现给我们构建强大的企业应用系统提供了可能。但用这些技术构建的系统非常的繁乱，所以在此之上，我们需要一个规则、一个把这些技术组织起来的规则，这就是框架，Struts便应运而生。基于Struts开发的应用由3类组件构成：控制器组件、模型组件、视图组件Struts的validate框架是如何验证的？在struts配置文件中配置具体的错误提示，再在FormBean中的validate()方法具体调用。说下Struts的设计模式MVC模式: web应用程序启动时就会加载并初始化ActionServler。用户提交表单时，一个配置好的ActionForm对象被创建，并被填入表单相应的数据，ActionServler根据Struts-config.xml 文件配置好的设置决定是否需要表单验证，如果需要就调用ActionForm的Validate（）验证后选择将请求发送到哪个Action，如果 Action不存在，ActionServlet会先创建这个对象，然后调用Action的execute（）方法。Execute（）从 ActionForm对象中获取数据，完成业务逻辑，返回一个ActionForward对象，ActionServlet再把客户请求转发给 ActionForward对象指定的jsp组件，ActionForward对象指定的jsp生成动态的网页，返回给客户。单例模式Factory(工厂模式)：123定义一个基类===》实现基类方法（子类通过不同的方法）===》定义一个工厂类（生成子类实例）===》开发人员调用基类方法Proxy(代理模式) spring工作机制及为什么要用?1️⃣ spring mvc请所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责负责对请求进行真正的处理工作。2️⃣ DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.3️⃣ DispatcherServlet请请求提交到目标Controller4️⃣ Controller进行业务逻辑处理后，会返回一个ModelAndView5️⃣ Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象6️⃣ 视图对象负责渲染返回给客户端。 Hibernate在数据库中条件查询速度很慢的时候,如何优化? 建索引 减少表之间的关联 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 在hibernate中进行多表查询,每个表中各取几个字段,也就是说查询出来的结果集并没有一个实体类与之对应,如何解决这个问题? 按照Object[]数据取出数据，然后自己组bean 对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 field2) ，然后在hql里面就可以直接生成这个bean了。具体怎么用请看相关文档，我说的不是很清楚。 Session在加载实体对象时，将经过的过程：首先，Hibernate中维持了两级缓存。第一级缓存由Session实例维护，其中保持了Session当前所有关联实体的数据，也称为内部缓存。而第二级缓存则存在于SessionFactory层次，由当前所有由本 SessionFactory构造的Session实例共享。出于性能考虑，避免无谓的数据库访问，Session在调用数据库查询功能之前，会先在缓存中进行查询。首先在第一级缓存中，通过实体类型和id进行查找，如果第一级缓存查找命中，且数据状态合法，则直接返回。之后，Session会在当前“NonExists”记录中进行查找，如果“NonExists”记录中存在同样的查询条件，则返回null。 “NonExists”记录了当前Session实例在之前所有查询操作中，未能查询到有效数据的查询条件（相当于一个查询黑名单列表）。如此一来，如果 Session中一个无效的查询条件重复出现，即可迅速作出判断，从而获得最佳的性能表现。对于load方法而言，如果内部缓存中未发现有效数据，则查询第二级缓存，如果第二级缓存命中，则返回。如在缓存中未发现有效数据，则发起数据库查询操作（Select SQL），如经过查询未发现对应记录，则将此次查询的信息在“NonExists”中加以记录，并返回null。根据映射配置和Select SQL得到的ResultSet，创建对应的数据对象。将其数据对象纳入当前Session实体管理容器（一级缓存）。执行Interceptor.onLoad方法（如果有对应的Interceptor）。将数据对象纳入二级缓存。如果数据对象实现了LifeCycle接口，则调用数据对象的onLoad方法。返回数据对象。 Hibernate的主键生成机制 assigned主键由外部程序负责生成，无需Hibernate参与。 hilo通过hi/lo 算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态。 seqhilo与hilo 类似，通过hi/lo 算法实现的主键生成机制，只是主键历史状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。 increment主键按数值顺序递增。此方式的实现机制为在当前应用实例中维持一个变量，以保存着当前的最大值，之后每次需要生成主键的时候将此值加1作为主键。这种方式可能产生的问题是：如果当前有多个实例访问同一个数据库，那么由于各个实例各自维护主键状态，不同实例可能生成同样的主键，从而造成主键重复异常。因此，如果同一数据库有多个实例访问，此方式必须避免使用。 identity采用数据库提供的主键生成机制。如DB2、SQL Server、MySQL中的主键生成机制。 sequence采用数据库提供的sequence 机制生成主键。如Oralce 中的Sequence。 native由Hibernate根据底层数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式。 uuid.hex由Hibernate基于128 位唯一值产生算法生成16 进制数值（编码后以长度32 的字符串表示）作为主键。 uuid.string与uuid.hex 类似，只是生成的主键未进行编码（长度16）。在某些数据库中可能出现问题（如PostgreSQL）。 foreign使用外部表的字段作为主键。一般而言，利用uuid.hex方式生成主键将提供最好的性能和数据库平台适应性。 这10中生成OID标识符的方法,increment 比较常用,把标识符生成的权力交给Hibernate处理.但是当同时多个Hibernate应用操作同一个数据库,甚至同一张表的时候.就推荐使用identity 依赖底层数据库实现,但是数据库必须支持自动增长,当然针对不同的数据库选择不同的方法.如果你不能确定你使用的数据库具体支持什么的情况下.可以选择用native 让Hibernate来帮选择identity,sequence,或hilo.另外由于常用的数据库，如Oracle、DB2、SQLServer、MySql 等，都提供了易用的主键生成机制（Auto-Increase 字段或者Sequence）。我们可以在数据库提供的主键生成机制上，采用generator-class=native的主键生成方式。不过值得注意的是，一些数据库提供的主键生成机制在效率上未必最佳，大量并发insert数据时可能会引起表之间的互锁。数据库提供的主键生成机制，往往是通过在一个内部表中保存当前主键状态（如对于自增型主键而言，此内部表中就维护着当前的最大值和递增量），之后每次插入数据会读取这个最大值，然后加上递增量作为新记录的主键，之后再把这个新的最大值更新回内部表中，这样，一次Insert操作可能导致数据库内部多次表读写操作，同时伴随的还有数据的加锁解锁操作，这对性能产生了较大影响。因此，对于并发Insert要求较高的系统，推荐采用uuid.hex 作为主键生成机制 谈谈Hibernate中inverse的作用inverse属性默认是false,就是说关系的两端都来维护关系。比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp)i如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false” 或默认时，会导致在中间表中插入两次关系。 说说Hibernate中的update()和saveOrUpdate()的区别，session的load()和get()的区别。saveOrUpdate()方法可以实现update()的功能，但会多些步骤，具体如下：如果对象在该session中已经被持久化，不进行操作；对象的标识符属性(identifier property)在数据库中不存在或者是个暂时的值，调用save()方法保存它；如果session中的另一个对象有相同的标识符抛出一个异常；以上皆不符合则调用update()更新之。Session.load/get方法均可以根据指定的实体类和id从数据库读取记录，并返回与之对应的实体对象。其区别在于：如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObjectNotFoundException；load方法可返回实体的代理类实例，而get方法永远直接返回实体类；load方法可以充分利用内部缓存和二级缓存中的现有数据，而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，直接调用SQL完成数据读取。 Hibernate笔试题(1)一般情况下，关系数据模型与对象模型之间有哪些匹配关系（多选）A)表对应类B)记录对应对象C)表的字段对应类的属性D)表之间的参考关系对应类之间的依赖关系(2)以下关于SessionFactory的说法哪些正确？（多选）A)对于每个数据库事务，应该创建一个SessionFactory对象B)一个SessionFactory对象对应一个数据库存储源。C)SessionFactory是重量级的对象，不应该随意创建。如果系统中只有一个数据库存储源，只需要创建一个。D)SessionFactory的load()方法用于加载持久化对象(3)Customer类中有一个Set类型的orders属性，用来存放Order订单对象，在Customer.hbm.xml文件中，用哪个元素映射orders属性？A) B) C) D)(4)元素有一个cascade属性，如果希望Hibernate级联保存集合中的对象，casecade属性应该取什么值？（单选）A)noneB)saveC)deleteD)save-update(5)以下哪些属于Session的方法？A)load()B)save()C)delete()D)update()E)open()F)close()(6)以下程序的打印结果是什么？（单选）tx = session.beginTransaction();Customer c1=(Customer)session.load(Customer.class,new Long(1));Customer c2=(Customer)session.load(Customer.class,new Long(1));System.out.println(c1==c2);tx.commit();session.close();A)运行出错，抛出异常B)打印falseC)打印true(7)以下程序代码对Customer的name属性修改了两次：tx = session.beginTransaction();Customer customer=(Customer)session.load(Customer.class,new Long(1));customer.setName(\”Jack\”);customer.setName(\”Mike\”);tx.commit();执行以上程序，Hibernate需要向数据库提交几条update语句？（单选）A)0 B)1 C)2 D)3(8)在持久化层，对象分为哪些状态？（多选）A)临时状态B)独立状态C)游离状态D)持久化状态(9)对于以下程序，Customer对象在第几行变为持久化状态？（单选）Customer customer=new Customer(); //line1customer.setName(\”Tom\”); //line2Session session1=sessionFactory.openSession(); //line3Transaction tx1 = session1.beginTransaction(); //line4session1.save(customer); //line4tx1.commit(); //line5session1.close(); //line6A) line1 B)line2 C)line3 D)line4 E)line5 F)line6(10)对于以下程序，Customer对象在第几行变为游离状态？（单选）Customer customer=new Customer(); //line1customer.setName(\”Tom\”); //line2Session session1=sessionFactory.openSession(); //line3Transaction tx1 = session1.beginTransaction(); //line4session1.save(customer); //line4tx1.commit(); //line5session1.close(); //line6A) line1 B)line2 C)line3 D)line4 E)line5 F)line6(11)以下哪一种检索策略利用了外连结查询？（单选）A)立即检索 B)延迟检索 C)迫切左外连结检索(12)假设对Customer类的orders集合采用延迟检索策略，编译或运行以下程序，会出现什么情况（单选）Session session=sessionFactory.openSession();tx = session.beginTransaction();Customer customer=(Customer)session.get(Customer.class,new Long(1));tx.commit();session.close();Iterator orderIterator=customer.getOrders().iterator();A)编译出错 B)编译通过，并正常运行 C)编译通过，但运行时抛出异常(13)关于HQL与SQL，以下哪些说法正确？（多选）A)HQL与SQL没什么差别B)HQL面向对象，而SQL操纵关系数据库C)在HQL与SQL中，都包含select,insert,update,delete语句D)HQL仅用于查询数据，不支持insert,update和delete语句(14)事务隔离级别是由谁实现的？（单选）A)Java应用程序 B)Hibernate C)数据库系统 D)JDBC驱动程序(15)悲观锁与乐观锁，哪个具有较好的并发性能？（单选）A)悲观锁 B)乐观锁答案：(1)A,B,C (2)B,C (3)A (4)D (5)A,B,C,D,F (6)C (7)B (8)A,C,D (9)D (10)F (11)C (12)C (13)B,D (14)C (15)B1.strust的。Action是不是线程安全的？如果不是有什么方式可以保证Action的线程安全？如果是，说明原因2.MVC，分析一下struts是如何实现MVC的3.struts中的几个关键对象的作用(说说几个关键对象的作用)4.spring说说AOP和IOC的概念以及在spring中是如何应用的5.Hibernate有哪几种查询数据的方式6.load()和get()的区别 Struts的工作原理在Struts中，用户的请求一般以.do作为请求服务名，所有的.do请求均被指向ActionSevlet， ActionSevlet根据Struts-config.xml中的配置信息，将用户请求封装成一个指定名称的FormBean，并将此 FormBean传至指定名称的ActionBean，由ActionBean完成相应的业务操作，如文件操作，数据库操作等。每一个*.do均有对应的 FormBean名称和ActionBean名称，这些在Struts-config.xml中配置。 Struts优点与缺点Struts是开源软件，使开发者能更深入的了解其内部实现机制。Struts 优点：业界”标准”（很多成功案例），学习资源丰富。Struts的优点主要集中体现在两个方面：Taglib和页面导航。a、利用Struts提供的taglib可以大大节约开发时间。b、维护扩展比较方便。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。c、表现与逻辑分离d、表单验证解决了请求数据的验证问题，增强了系统健壮性。e、便于团队开发Struts缺点：a、大量的使用标签，对于初学者难度较大。b、ActionForms使用不便、无法进行单元测试（StrutsTestCase只能用于集成） Struts提供了几个标签库？都是什么标签库？Struts提供了五个标签库，即：HTML、Bean、Logic、Template和Nested。HTML 标签 用来创建能够和Struts 框架和其他相应的HTML 标签交互的HTML 输入表单Bean 标签 在访问JavaBeans 及其属性，以及定义一个新的bean 时使用Logic 标签 管理条件产生的输出和对象集产生的循环Template 标签 随着Tiles框架包的出现，此标记已开始减少使用Nested 标签 增强对其他的Struts 标签的嵌套使用的能力 Tiles框架是什么？Tiles框架为创建Web页面提供了一种模板机制，它能将网页的布局和内容分离。1、MVC的各个部分都有那些技术来实现?如何实现?答：MVC是Model－View－Controller的简写。“Model”代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）,“View”是应用的表示面（由JSP页面产生），“Controller”是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。2、说说Struts的应用。答：Struts 是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。采用Struts能开发出基于MVC设计模式的应用构架。 Struts的主要功能包括：一包含一个controller servlet，能将用户的请求发送到相应的Action对象。二JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。三提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。3、strust的Action是不是线程安全的？如果不是有什么方式可以保证Action的线程安全？如果是请说明原因。答：不是线程安全的，只要不申明类变量就可以保证线程安全。因为只存在一个Action类实例，所有线程会共享类变量。4、应用服务器具体包括那些？答：应用服务器具体包括：BEA WebLogic Server、IBM WebSphere Application Server、Oracle9i Application Server、JBoss和Tomcat等。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java面试题</tag>
      </tags>
  </entry>
</search>
